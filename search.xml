<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(三)</title>
    <url>/posts/edd61a92.html</url>
    <content><![CDATA[<h2 id="使用游离态"><a href="#使用游离态" class="headerlink" title="使用游离态"></a>使用游离态</h2><p>如果一个 entity 实例脱离了持久化上下文的管理，我们就称它为游离态。当持久化上下文关闭之后，它就不再提供 id 映射服务。当你使用游离态的 entity 实例时可能会遇到一些问题，所以，一定要保证你明白如何处理游离态实例。</p>
<span id="more"></span>

<h3 id="游离态实例的标识"><a href="#游离态实例的标识" class="headerlink" title="游离态实例的标识"></a>游离态实例的标识</h3><p>如果你用相同的数据 ID 在相同的持久化上下文中查询 entity，你会得到存在于 JVM 堆中的两个不同的实例引用。代码样例：</p>
<p><img src="https://s2.loli.net/2021/12/20/3vXAuG5bkYHrhBZ.png" alt="image-20211220193030280"></p>
<p>首先，你创建了一个持久化上下文并且加载了某些 entity 实例。因为 a 引用和 b 引用都是在同一个持久化上下文中获取的，所以它们都有相同的 java 标识。所以用 equals() 进行比较它们是相等的。显然，它们也拥有相同的数据库标识。它们引用着相同的 Item 实例，都属于被持久化上下文管理的持久态。之后，提交了事务，并且关闭了持久化上下文。当持久化上下文关闭之后，a 引用和 b 引用都转为游离态。你正在使用处于标识可以被认证的范围之外的引用。</p>
<p>你可以看到从不同持久化上下文加载出来的 a 和 c ，它们就完全不相同。所以，a.equalis(c) 永远反馈 false。但是它们的 id 是相同的。这些行为在你用 equal 处理游离态数据时会出现一些问题。例如以下代码样例（上面代码的拓展）：</p>
<p><img src="https://s2.loli.net/2021/12/20/Vb7HGgUE5QSqeBj.png" alt="image-20211220193050009"></p>
<p>在代码中，将三个引用放入到 set 集合中。所有的引用都是游离态实例的。现在，如果你检查集合元素的数量你认为是多少？</p>
<p>Set 集合不会出现重复元素。重复的会被检测出来；无论何时，你只要往里添加一个元素，就会自动的调用 Item#equals() 方法对集合内所有元素进行比较。如果返回 true ，那么这次添加就不会发生。</p>
<p>默认情况下，所有 Java class 的 equals() 方法都继承自 java.lang.Object。这个方法使用 (==) 双等号来判断两个引用是否指向相同的内存地址。</p>
<p>你或许会猜到集合中元素的数量是 2 。毕竟，a 和 b 指向相同的内存地址；它们是通过相同的持久化上下文加载出来的。你从另一个持久化上下文中获取了引用 c ；它指向堆中不同的内存地址。你有三个引用，却只指向两个不同的内存地址，但是，你知道这些只是因为你看到了加载数据的代码。在真实的项目中，你可能不知道 a、b 和 c 是从不同的持久化上下文中加载出来的。此外，你期望集合中只有一个元素，因为 a,b,c 都代表着数据库的同一条数据，都是相同的 Item 。</p>
<p>当你比较游离态 entity 实例是否相等时，必须为每个 entity class 实现自己的 equals() 和 hashCode() 方法。如果你不使用游离态 entity 实例，那就使用 Object#equals()的默认实现就好。即使你在项目中使用了游离态实例也不用太担心，因为你如果只是在屏幕中渲染它们，而没有对它们进行比较，或者将它们放入 Set 集合以及 Map 中就没什么好担心的。</p>
<p>许多新接触 JPA 的开发者认为他们必须为每个 entity 都提供自己的 equals() 和 hashCode() 方法，但是事实并非如此。在 18.3 节中我们将展示，如何使用 extended 持久化上下文进行程序设计。这个策略可以让持久化上下文横跨多个会话和事务。记住，不要对两个来自不同会话的游离态 entity 实例进行比较！</p>
<p>我们总结一下，如果你想使用游离态实例，你就必须通过自己实现的 equals() 和 hashCode() 方法进行比较。</p>
<h3 id="实现自己的比较方法"><a href="#实现自己的比较方法" class="headerlink" title="实现自己的比较方法"></a>实现自己的比较方法</h3><p>你可以通过多种方式实现 equals() 和 hashCode() 方法。记住，如果你要覆盖 equals() 方法，就必须覆盖 hashCode() 方法。如果两个实例相等，那么它们的 hashCode 就一定相等。</p>
<p>一个取巧的实现 equals() 方法的方式是仅仅比较它们的 id 是否相等。基本上，如果两个 Item 的 id 相等，那么它们一定相同。如果 id 为 null ，那么它一定是还没有被保存起来的瞬时态。</p>
<p>遗憾的是这个方式有一个很严重的问题：除非实例被持久化不然 id 不会被 Hibernate 赋值。如果一个瞬时态的实例在被保存前被我们放到 Set 中，之后当你保存它，那么它在 Set 中的 hash 值将会改变。这种情况不满足 java.util.Set 的约束条件，这会破坏集合。在特定情况下，这个问题会让基于 set 实现的级联映射功能失效。所以，我们强烈反对基于数据库 id 的相等比较。</p>
<p> 使用我们推荐的方式解决这个问题之前，你需要知道 business  key. 的概念。business  key 是一个属性，或者一些属性的组合，每个相同的 entity 实例，都拥有相同的数据 Id。本质上，如果你不使用代理主键（id) 的话，业务主键（ natural key ）是更常使用的。与业务主键不同，代理主键在 business key 从不改变，或者改变很少的情况下是没有必要使用的，业务主键就够用了。</p>
<p><strong>ps: 这里的 natural key 等同于 business  key 可以统称为业务主键。</strong></p>
<p>我们认为每个 entity class 都需要一个业务主键，即使这个业务主键要包含一个类的所有属性。如果你的客户在屏幕中的列表进行查找，他怎么分辨 A、B、C ？答案是用你的业务主键。用户会用业务主键来当做一个特殊数据的唯一标识，而应用本身和数据库会使用代理主键。业务主键通常对应着数据库的 UNIQUE（唯一性） 约束。</p>
<p>让我们为 User 实现自己的 equals() 和 hashCode() 方法，这会比为 Item 实现更容易。对于 User 来说，username 是一个较好的业务主键。业务主键通常都是需要使用的，它通常被设置为数据库的唯一约束，并且它通常 不会被更改。</p>
<p><img src="https://s2.loli.net/2021/12/22/X9v3M8AZHjqWxdE.png" alt="image-20211222125415499"></p>
<p>你可能注意到了，在 equals() 方法中我们调用了 other 参数的 getter 方法。这一点是非常重要的，因为 other 的引用可能是一个 Hibernate 的代理对象，并不是真实的持久态实例，你无法直接访问 User 代理对象的 username 属性。为了让代理对象初始化并且获取对应的属性值，你需要通过一个 getter 方法进行访问。这一点 Hibernate 做的并不透明，但是使用 getter 方法访问属性比直接访问要更好。</p>
<p>判断 oher 参数是否为 User 应该使用 instanceof，而不是比较 getClass() 的值是否一样。因为 oher 可能是在运行时生成的一个 User 代理，所以它们可能类型不同，但是却是超类和子类的关系。你可以在 12.1.1 章节中找到更多关于代理的信息。</p>
<p>现在你可以安全的对在持久态下的 User 进行比较了。</p>
<p>  <img src="https://s2.loli.net/2021/12/22/7PM16bQUR3CjLd4.png" alt="image-20211222131056026"></p>
<p>现在，你可以正确的比较持久态和游离态的引用了。</p>
<p><img src="https://s2.loli.net/2021/12/22/5cSEpwagWG8Bn1R.png" alt="image-20211222131339747"></p>
<p>对于一些 entity ，业务主键的组成可能很复杂。下面这些提示应该可以帮助你更好的使用它。</p>
<ul>
<li>思考一下，当比较两个 entity 是否相等时你的应用需要哪些属性。用户用哪些属性辨别屏幕上的两个元素是否一样？这些属性可能就是你的业务主键。</li>
<li>任何一个不可改变的属性都可以当做业务主键的备选。当然，一些可能发生改变的属性也是可以选择的，但是它们的改变不能太频繁，或者当它们改变的时候你可以控制它们所处的环境——例如，确保在这个时候没有在 Set 中使用它们。</li>
<li>数据库唯一约束包含业务主键的每个属性是比较好的。需要注意的是，业务主键要设置的足够精确，避免重复。</li>
<li>任何时间类型的属性，或者与时间相关的属性通常都适合被选中作为业务主键的一部分，例如数据的创建时间戳，但是 System.currentTimeMillis() 是否准确需要依赖虚拟机和操作系统。我们建议误差不要超过 50 毫秒，如果超过这个范围的情况下，同时业务主键只有这一个属性，那么这个业务主键就不够精确了，有可能出现两条不同的数据却拥有相同的业务主键的情况。</li>
<li>你可以使用数据库主键作为业务主键的一部分。这似乎与我们之前的说明相矛盾，因为我们还没有讨论 entity id 的数值。你在某种情况下可以使用一个 entity 实例的数据库 id。例如，现在有 Bid class，它的业务主键使用的是 Item 的 id ，而这两个类是用投资金额关联的。你甚至可以在数据库添加这个业务主键的唯一索引。你现在可以使用 Item 的 id 是因为在 Bid 类的整个生命周期中这个 id 都不会被更改，所以在构造 Bid 时需要一个已经处于持久态的 Item。</li>
</ul>
<p>如果你遵从我们的建议，你将会很容易定义出合理的业务主键。如果你遇到一个很复杂的场景，你在解决问题时可以不用考虑 Hibernate，因为这本质就是一个面向对象的问题。要留意在实例之间进行比较的情况下子类没有正确覆盖父类 equals() 方法的问题。要同时满足它的对称性和传递性还是有点棘手的；关于自定义比较方法的更多信息请阅读 Effective Java, 2nd edition,by Joshua Bloch (Bloch, 2008)。</p>
<p>User class 现在已经是游离态的了，你可以安全的将它的实例放入不同持久化上下文的 Set 集合中。下面，我们将看一些使用游离态的例子，这会对你很有益处。</p>
<p>有时候你或许想要手动将一个 entity 实例从持久化上下文中分离出来成为游离态。</p>
<h3 id="分离-entity-实例"><a href="#分离-entity-实例" class="headerlink" title="分离 entity 实例"></a>分离 entity 实例</h3><p>你不需要等待持久化上下文关闭后才能获得游离态实例。因为你可以手动的将 entity 实例从持久化上下文中剥离出来。</p>
<p><img src="https://s2.loli.net/2021/12/23/gDtjFpKfmxJGw28.png" alt="image-20211223204351355"></p>
<p>例子中的 EntityManager#contains() 方法如果返回 true 就表示这个实例在当前的持久化上下文中是持久态的。</p>
<p>你现在就可以使用游离态的 user 了。许多应用都会在持久化上下文关闭后对数据进行只读或者渲染操作。</p>
<p>在持计划上下文关闭后再修改已经加载出来的 user 实例是不会对数据库的数据产生影响的。当然， JPA 是允许你在一个新的持久化上下文中将更改同步到数据库中的。</p>
<h3 id="合并-entity-实例"><a href="#合并-entity-实例" class="headerlink" title="合并 entity 实例"></a>合并 entity 实例</h3><p>我们假设你现在想要修改一个游离态的 User 实例，并且想将更改保存到数据库中。</p>
<p><img src="https://s2.loli.net/2021/12/24/j6kuyRvXCdn8MUD.png" alt="image-20211224121208350"></p>
<p>考虑下图展示的程序运行步骤，它看起来并不是很复杂。</p>
<p><img src="https://s2.loli.net/2021/12/24/le8RipJYMBkEOoN.png" alt="image-20211224121557636"></p>
<p>处于游离态的 User 实例的新名字会被存储到数据库中。首先，当你调用 merge() 方法的时候，Hibernate 会去持久化上下文中检查当前是否拥有跟你要 merge() 实例 id 相同的持久态实例。</p>
<p>在当前这个例子中，持久化上下文是空的；没有从数据库中加载任何数据。因此，Hibernate 会根据这个 id 从数据库将数据加载出来。然后，merge() 会将游离态 entity 实例的数据拷贝到已经被持久化上下文加载出来的数据中。换句话说，你在游离态 user 实例中设置的 username 也会设置到当前持久化上下文中的持久态 user 实例中，这个持久态实例将通过 merge() 方法返回给你。</p>
<p>现在，我们不再使用过时的游离态实例的引用；因为 detachedUser 已经不是当前最新的状态了。你可以继续对 merge() 返回的 mergedUser 进行修改，Hibernate 会在持久化上下文 flush 的时候执行一个 update 语句。</p>
<p>如果持久化上下文中没有这个 id 的实例，并且在数据库中也查不到，那么 Hibernate 将创建一个新的 User 实例。然后 Hibernate 会将游离态实例的数据拷贝到这个新的实例中，当持久化上下文与数据库同步的时候，这条数据就会被插入到数据库中。</p>
<p>如果你送给 merge() 的实例不是游离态，而是瞬时态的，那么 Hibernate 会创建一个新的 User 实例，然后将数据都拷贝到这个新实例上，之后会将它转换成持久态并且返还给你。在一些简单的场景中，merge() 既可以处理游离态实例，也可以处理瞬时态实例。相同的是，Hibernate 都会将持久态的实例返还给你。</p>
<p>( An  application  architecture  based  on  detachment  and  merging  may  not  call  thepersist() operation. 这句话不知道怎么翻译。纵观上下文应该是表达保存游离态数据时一般不会调用 persist() 操作)。你可以将瞬时态和游离态的实例存储到数据库中。但是重要的是它会返回不同状态的实例的引用，你要怎么在代码中处理这种引用的转换。你需要舍弃对 detachedUser 的引用，同时持有当前被返回的 mergedUser 的引用。你应用中的其他组件也要这么做。</p>
<blockquote>
<p><strong>我可以重新使用游离态实例吗？</strong></p>
<p>Hibernate 的 Session 提供了 saveOrUpdate() API , 通过它我们可以重新使用游离态实例。它可以接受瞬时态或者游离态实例，并且不会返回任何东西。给定的实例将在方法调用后转换成持久态实例。这样你就不用去转换引用了。如果你的参数是瞬时态的将执行  INSERT 如果是游离态的将执行 UPDATE 。我们建议你使用 merge() 代替 saveOrUpdate() 方法，因为它是符合通用标准的，很容易与其他框架集成。另外，如果游离态实例没有被更改那就只会触发 SELECT 而不会执行 UPDATE。如果你想知道 Session#saveOrUpdateCopy 方法做了什么，其实它和 EntityManager#merge 一样。</p>
</blockquote>
<p>如果你想要删除游离态实例，那么你首先要合并（merge) 它。然后对 merge() 返回的持久态实例调用 remove() 方法。</p>
<p>我们将会在 18 章重新接触游离态的合并，并且会用这个策略实现一个更复杂的功能。</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul>
<li>我们讨论了在一个 JPA 应用中与 entity 实例交互必备的的和一些可选的策略。</li>
<li>你学习了 entity 实例的生命周期并且知道持久态、游离态和删除态是怎么回事儿。</li>
<li>JPA 中最重要的 API 是 EntityManager。</li>
<li>在大多数应用中，数据的存储和加载并不是单独发生的。Hibernate 经常被使用在高并发的应用中，有很多线程同时访问数据库。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>ORM</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 实战第二版 中文翻译 事务和并发篇(一)</title>
    <url>/posts/2622ec0e.html</url>
    <content><![CDATA[<p>在这章，我们终于要学习事务相关的知识了：在应用中如何创建工作单元并解决并发问题。（ps: 想了解什么是 <a href="https://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%BA%8C/">工作单元</a> 请看这里。）工作单元是一个原子操作。事务可以让你设置工作单元的边界，让其不会受其他工作单元影响。在一个拥有许多用户的应用中，或许会有很多人同时访问这些工作单元的情况。</p>
<p>在处理并发问题之前，我们首先集中精力了解下最基础的工作单元：数据库和系统事务。你将学会使用 Java 代码定义工作单元和事务划分相关的 API。我们将讨论如何保持隔离，并且用乐观锁和悲观锁控制并发访问。</p>
<span id="more"></span>

<p>最后，我们会看一些在没有事务的情况下访问数据库的特殊案例和 JPA 的特性。</p>
<h2 id="事务的要素"><a href="#事务的要素" class="headerlink" title="事务的要素"></a>事务的要素</h2><p>在某些场景下应用需要将几件事情一次性做完。例如，当一次拍卖结束后，CaveatEmptor 应用必须执行三个不同的任务：</p>
<ol>
<li>寻找拍卖的中标者。</li>
<li>收取卖方的手续费。</li>
<li>通知卖方和买方。</li>
</ol>
<p>如果因为外部的信用卡系统的问题导致扣款失败会怎样？这个商业需求可能会规定要么所有任务全部成功要么全部失败。因此，可以称这些步骤属于同一个事务或者工作单元。如果其中一个步骤失败了，那么整个工作单元都必须失败。</p>
<h3 id="ACID-属性"><a href="#ACID-属性" class="headerlink" title="ACID 属性"></a>ACID 属性</h3><p>ACID 是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）的缩写，代表一个事务中的所有操作都是原子的。此外，事务允许多个用户并发的操作相同的数据，而且不会出现数据不一致的问题。一个正在运行的事务不能访问另一个同时也在运行的事务；他们应该独立的工作。事务中的更改应该是被持久化的，即使在事务完成之后系统崩溃了也不应该有数据丢失。</p>
<p>另外，你想要事务正确的执行。例如，业务逻辑是应用只能对卖方扣款一次，而不是两次。这个逻辑是合理的，但是你没办法从数据库层面去约束它。因此，事务的正确性只能由应用程序自己保证，而数据库要保证数据的一致性。这些属性一起组成了 ACID 标准。</p>
<h3 id="数据库与系统事务"><a href="#数据库与系统事务" class="headerlink" title="数据库与系统事务"></a>数据库与系统事务</h3><p>我们之前已经提到过系统和数据库事务了。再回头看下最后提出的那个问题：在一个拍卖功能的事务结束期间，我们或许会在数据库中记录中标金额。之后，在相同的事务中，我们会与一个外部的信用卡系统交互对卖方的账户进行扣款（服务费）。这个事务会横跨多个系统，并且会与很多子事务共同完成这个任务，这些子事务包括但不限于数据库连接的事务、外部扣款系统的事务。</p>
<p>数据库的事务越短越好，因为它不仅会增加数据库资源的使用，而且在并发访问的情况下独占锁会导致其他访问被阻塞。一般情况下，一批数据操作会使用单独的事务进行控制。</p>
<p>无论你在事务中执行什么数据库操作，你都必须设置工作单元的边界。你必须开启事务，并且在某个时间点将更改进行提交。无论发生任何异常，你都必须将数据回滚到更改之前的状态。这个过程要依赖于你使用的技术，并且涉及一定程度的人工干预。总之，设置事务的开始和结束这种边界，即可以使用编程式也可以使用声明式。</p>
<h3 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h3><p>在 Java SE 中你可以调用 JDBC API 设置事务的边界。你可以通过调用 setAutoCommit(false) 在JDBC 链接上开启一个事务并且在事务结束时调用 commit() 方法。你可以在事务运行的任意时刻调用 rollback() 方法让事务立即回滚。</p>
<p>在一个需要横跨多个系统对数据进行操作的应用中，有些工作单元可能包含多个事务。在这个场景中，你不能仅仅通过 JDBC 达到原子操作的目的。你需要一个可以在一个系统事务中处理多个事务资源的事务管理器（这里描述的应该是一个分布式事务，这个分布式事务由多个应用的多个事务共同组成）。JTA 标准事务管理器可以对分布式事务进行管理，让你不用关心太多的底层细节。JTA 最主要的 API 是 UserTransaction 接口中的 begin() 方法和 commit() 方法。</p>
<blockquote>
<p><strong>关于事务的其他 API</strong></p>
<p>JTA 提供了一个很好的关于分布式事务系统的抽象。许多开发者仍然以为只能在 Java EE 的应用中使用 JTA。但是，当前有很多高品质独立的 JTA 服务可以使用，例如 Bitronix 和 Atomikos，它们可以被使用在任何 Java 环境中，而且很容易上手。考虑将这些解决方案当做启动 JTA 的数据路连接池。</p>
<p>你应该尽可能的使用 JTA ，并且要避免使用私有事务 API 例如 org.hibernate.Transaction 或者限制非常多的 javax.persistence.EntityTransaction。这些 API 都会在 JTA 在 EJB运行容器外部还不可用时就会被创建。</p>
</blockquote>
<p>在 10.2.1 节我们会再一次学习事务，并且主要学习如何处理异常。下面这些代码展示了发生异常时如何回滚数据。</p>
<p><img src="https://s2.loli.net/2021/12/25/S6xe14lGWDMI8a7.png" alt="image-20211225234127886"></p>
<p>这段代码最复杂的地方就是处理异常的部分：我们现在就讨论这部分内容。首先你需要知道事务管理器和 EntityManager 是如何配合使用的。</p>
<p>EntityManager 是懒加载的，我们在前几章讨论过这个话题，它直到 Sql 必须被执行的时候才会去获取数据库连接。JTA 也是如此：当你没有访问任何事务资源的时候，提交一个空的事务是非常节省资源的。例如，你可以在服务器中这么操作，这样的话，每次请求都不会消耗资源也不会对数据库进行上锁。</p>
<p>当你创建一个 EntityManager 的时候，它会在当前工作线程中寻找 JTA 事务。如果 EntityManager 找到了这个事务，那么它就会加入这个事务，并且监听事务消息。这就意味着如果你想让上述流程起效，那么你就必须在同一个线程中调用 UserTransaction#begin()  方法和 EntityManagerFactory#createEntityManager() 方法。默认情况下，Hibernate 会像第 10  章所述，会自动提交事务。</p>
<p>当 EntityManager 在当前线程中无法找到事务时，它就会进入 unsynchronized 模式，在这模式中， JPA 将不会自动提交事务。晚一些我们将会对这种行为进行更深入的讨论；当你在设计很复杂的功能时，这是一个很方便的特性。</p>
<p>如果一个事务运行的时间太长就会被事务管理器关掉。记住数据库事务要尽可能的短。Bitronix 作为一个 JTA 服务提供者，它的默认超时时间是 60 秒，当前你可以在事务开始前调用 UserTransaction#setTransactionTimeout(). 方法覆盖这个参数。</p>
<p>我们用前面的代码片段来谈论如何处理异常。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果在调用 EntityManager 时或者事务提交时抛出异常，你必须检查当前系统事务的状态。当异常发生的时候，Hibernate 会让事务进行回滚。这意味着，在这个事务中进行的更改都不会生效。因为是你开启的事务，所以检查事务是否为 STATUS_MARKED_ROLLBACK 状态也是你的工作。如果 Hibernate 回滚失败了那么这个事务仍然会保持 STATUS_ACTIVE 状态。在这个案例中，你也可以调用 UserTransaction#rollback() 去取消执行任何已经发送到数据库的 Sql 语句。</p>
<p>JPA 的任何操作，包括刷新持久化上下文时都有可能抛出 RuntimeException 异常。但是 UserTransaction#begin(), commit(),  和evenrollback() 方法抛出的是 Exception 异常。 异常在回滚的时候需要进行特殊处理的：你想要捕获这个异常并且将它输出到日志中；否则就会导致回滚失败。你也可以在回滚之后继续将异常往上抛出，这种情况下你可能会有一个拦截器，对异常进行统一处理，例如在屏幕上渲染一些错误信息，或者联系运维团队。在回滚时又出现异常是很难处理的，我们建议将它输出到日志，并且对其进行人工干预。因为回滚失败代表着系统有很多问题。</p>
<p>Hibaernte 抛出的异常都是 RuntimeException 的子异常，了解它们会对你进行异常处理有很多帮助。</p>
<ul>
<li>HibernateException 是很常见的异常。你必须检查这个异常信息，或者通过调用 getCause() 方法获得更多信息。</li>
<li>JDBCException 一般出现在 Hibernate 与 JDBC 进行交互的时候。这类异常也可能是某些 Sql 导致的，你可以通过调用 getSQL() 方法获取到导致异常发生的 Sql。这个 JDBC 链接抛出的内部异常可以通过调用 getSQLException() 或者 getCause() 方法得到，并且通过调用 getErrorCode() 可以获取数据库特定的异常代码信息。</li>
<li>JDBCException 及其子类在 Hibernate 中存在一个转换器，可以通过数据库驱动将它转换成更有意义的信息。可以转换的异常有 JDBCConnectionException, SQLGrammarException, LockAcquisitionException,DataException,  和  ConstraintViolationException，主流数据库都为 Hibernate 提供了相应的方言。你也可以通过 SQLExceptionConverterFactory 类为你的数据库或者插件配置自定义的转换器。</li>
</ul>
<p>很多开发者看到 Hibernate 对异常有这么详细的类型划分都很高兴。但是这可能让你误入歧途。例如，你或许会为了达到某种校验的目的去捕获 ConstraintViolationException 异常。如果你忘记给 Item#name 属性赋值，同时它对应的数据库字段被设置为 NOT NULL。当你试图去刷新持久化上下文的时候 Hibernate 会抛出异常。这种情况下为什么不能捕获它并且将失败信息（使用自己定义的错误码和描述信息）展示给开发者，让他们改正这个问题？因为这个策略会有两个明显的问题。</p>
<p>第一，根据数据库抛出的未检查的值来看是什么问题对于一个可拓展的应用来说并不是一个很好的策略。应该在应用层实现一些数据校验工作。第二，异常对于当前工作单元来说是致命的，但是这不应该是让一个应用的使用者去处理它：使用者希望在工作单元内部进行处理。在不了解代码细节的情况下是很难处理的。我们建议你使用细粒度的异常类型去展示致命的异常信息，而不是用于去验证你的猜想。例如，当你捕获 ConstraintViolationException 异常时屏幕展示如下信息：“应用出现了 bug，某人在存储局时没有对数据进行校验，请将这个问题报告给程序员” 对于其他异常信息，你最好在屏幕中生成错误信息。</p>
<p>这么做对开发者是很有用的，让开发者可以快速判断是应用层出现了问题，还是数据库负载过高（无法获得锁资源）。对于校验，你可以使用 Bean Validation 框架。通过在 entity 上配置一些注解，Hibernate 可以在用户层对数据进行校验，并且可以自动生成 Sql ddl 规则。</p>
<p>你现在应该知道什么异常应该进行捕获处理了。或许你还有一个问题：你捕获异常后应该做什么，让事务回滚吗？Hibernate 抛出异常是致命的。这意味着你必须关闭当前持久化上下文。你不能继续使用已经抛出异常的 EntityManager。将异常信息输出到屏幕或者日志中，然后让用户使用一个全新的事务和持久化上下文重新开启会话。</p>
<p>以上所述并不包含所有情况，有些标准异常并不是不可挽回的：</p>
<ul>
<li>javax.persistence.NoResultException，这个异常会在 Query 或者 TypedQuery 调用 getSingleResult() 方法但是在数据库找不到对应的数据时被抛出。你可以通过异常处理代码对这个查询进行封装，然后继续使用这个持久化上下文。当前事务不会因为这个异常而进行回滚。</li>
<li>javax.persistence.NonUniqueResultException，这个异常会在 Query 或者 TypedQuery 调用 getSingleResult() 方法但是数据库放回多条数据时抛出。你可以通过异常处理代码对这个查询进行封装，然后继续使用这个持久化上下文。当前事务不会因为这个异常而进行回滚。</li>
<li>javax.persistence.QueryTimeoutException，当 Query 或者 TypedQuery 执行太久时抛出。不要让事务回滚。在某些情况下你或许想要再次查询。</li>
<li>javax.persistence.LockTimeoutException，当无法获取悲观锁时会抛出此异常。或许会发生在与数据库同步数据时候或者通过显式声明锁进行上锁的情况下。事务在这种情况下不回滚，你或许想要再次尝试这个操作。记住，不断重复已经访问数据库失败的操作不会解决问题。</li>
</ul>
<p>这个列表中没有包含 javax.persistence.EntityNotFoundException 异常，这个异常会被 EntityManager#getReference()、lock() 和 refresh() 方法抛出。Hibernate 会在你试图访问一个已经从数据库中被删除的数据时抛出此异常。这是一个致命的异常，事务会因此回滚，你必须关闭这个持久化上下文。</p>
<p>通过编程式进行事务的划分需要使用类似 JTA 的 UserTransaction 接口这样的应用代码才行。但是通过声明式的方式就不需要写多余的代码。</p>
<h3 id="声明式定义事务"><a href="#声明式定义事务" class="headerlink" title="声明式定义事务"></a>声明式定义事务</h3><p>在 Java EE 中，当你需要一个事务时你可以通过声明的方式获取一个事务。运行环境会负责处理相关的事情。通常情况下你需要在你的组件中配置一些注解，以达到开启事务的目的。</p>
<p>在 EJB 组件中，你可以使用  @javax.ejb.TransactionAttribute 注解来声明事务的边界。你可以在 18.2.1 中找到相关的代码示例。</p>
<p>你也可以使用一个较新的注解 @javax.transaction.Transactional 这个注解可以用在任何 Java EE 的应用中。你可以在 19.3.1 节找到相关的示例。</p>
<p>本章的代码示例可以运行在任意 Java SE 环境中，不需要任何运行容器。从现在开始，你将只能看到编程式的事务划分，直到我们学习 Java EE 的特殊应用例子为止。</p>
<p>下面让我们学习 ACID 最复杂的功能：如何将正在运行的工作单元相互独立。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>ORM</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(一)</title>
    <url>/posts/3c14a1db.html</url>
    <content><![CDATA[<h2 id="管理数据"><a href="#管理数据" class="headerlink" title="管理数据"></a>管理数据</h2><h3 id="entity-持久化过程中的生命周期"><a href="#entity-持久化过程中的生命周期" class="headerlink" title="entity 持久化过程中的生命周期"></a>entity 持久化过程中的生命周期</h3><p>因为 JPA 是一种透明的持久化机制，classes 不用关心他们自己的持久化行为，这样在写业务代码时就不需要关心数据是会被持久化还是仅仅保存在内存中。</p>
<p>应用层在调用方法时真的没必要关心实体的持久化。例如，你在调用Item#calculate-TotalPrice()业务方法时一点也不用关心持久化的事情。任何与持久化有关的应用，无论是否要把内存的数据保存到数据库中都必须使用持久化服务。换句话说，你必须使用 Java Persistence 的接口存储和查询数据。</p>
<span id="more"></span>

<p>当调用持久化的方法时，虽然不用关心 entity 是怎么持久化的，但是应用必须关注 entity 实体在持久化机制下的状态和生命周期。我们将用下面这段话作为生命周期的定义：entity 实体的状态将贯穿整个流程。我们也使用<em>工作单元</em>这个专业术语：众多改变状态的操作被认为是同一组操作（我理解这个就是指事务）。另一方面，我们还需要了解持久化服务提供的<em>持久化上下文</em>。把 <em>持久化上下文</em> 想象成一个可以记录你在一个事务中对数据的所有更改以及状态改变情况的服务。</p>
<p>我们现在要仔细分析这些术语：entity states（实体状态），persistence contexts（持久化上下文），managed scope（管理范围）。你可能更多的是考虑通过 sql 语句去操作数据库，以达到增删改查的目的。但是，能够学会使用 Java Persistence 的关键就是明白它是怎么进行状态管理的，我们会通过这一章节进行学习。</p>
<h4 id="Entity-实例的状态"><a href="#Entity-实例的状态" class="headerlink" title="Entity 实例的状态"></a>Entity 实例的状态</h4><p>不同的 ORM 框架会使用不同的专业术语，状态的定义也不一样，甚至在持久化的过程中，状态转换的过程也是不同的。此外，提供给客户端的使用方式也是不一样的。JPA 定义了四种状态，从而隐藏了 Hibernate 复杂的内部实现。下图展示了这些状态是如何转换的。</p>
<p><img src="https://s2.loli.net/2021/12/10/iBpw2yIkGXez3ls.png" alt="image-20211210131538695"></p>
<p>上图不仅展示了状态如何转换，也展示了如何通过调用 EntityManager 的 API 来触发状态的转换。我们将在这一章节仔细讲解这个图表；如果在这个过程中你忘记状态如何转换的，你就可以回来参考一下。下面让我们更深入的研究一下状态以及状态的转换。</p>
<h5 id="瞬时态"><a href="#瞬时态" class="headerlink" title="瞬时态"></a>瞬时态</h5><p>任何刚刚通过 Java 的 new 关键字生成的实例都是<strong>瞬时态</strong>的，这意味着如果没有强引用关联的话，那么很快它就会被垃圾回收清理掉，状态也会丢失。例如，new Item() 操作会创建一个 Item 瞬时态的实例，new Long() 和 new BigDecimal() 也是一样的。Hibernate 没有提供任何关于瞬时态的回调函数，所以如果你修改了处于瞬时态的 Item 实例，那么这次更改将不可能被取消。</p>
<p>如果一个 entity 实例的状态从瞬时态转换为持久态，那这个状态就是可以被管理的，通过调用  EntityManager#persist() 方法，或者让一个已经开启状态级联操作的持久态的实例引用它都可以达到此目的。</p>
<h5 id="持久态"><a href="#持久态" class="headerlink" title="持久态"></a>持久态</h5><p>一个持久态的 entity 实例说明它已经跟数据库产生了关联关系。它不是已经被持久化到数据库中了，就是在事务结束后会被持久化到数据库中。这个实例已经与数据库产生了映射关系，这部分内容可以参考 4.2 节内容。它的数据库标识存储在主键上。</p>
<p>应用可能创建多个实例，然后通过 调用 EntityManager#persist() 方法让它们持久化。当然还有另一种方法进行持久化，就是在已经被 JPA 持久化的实例上创建一个对这些新实例的引用。一个已经被持久化的 entity 实例可以通过查询条件，或者其他实例的级联操作从数据库中查询出来。持久态实例总是跟持久化上下文存在着引用关系，一会儿你就会了解到更多的信息。</p>
<h5 id="删除态"><a href="#删除态" class="headerlink" title="删除态"></a>删除态</h5><p>你可以通过很多方式将一个持久化实例从数据库中删除：例如，你可以调用  EntityManager#remove() 方法，这个在你开启了删除孤立元素配置的情况下，删除带有级联关系的实例时是非常有用的，它可以让你在没有配置级联操作的情况下，一同删除有级联关系的数据。</p>
<p>之后实例就会转换成删除态，在事务结束后删除态的实例会被从数据库中删除。在应用执行删除后，你就不应该再对删除态的实例进行操作。</p>
<h5 id="游离态"><a href="#游离态" class="headerlink" title="游离态"></a>游离态</h5><p>了解游离态之前，需要先明白如何从数据库中加载实例。你可以通过调用 EntityManager#find() 方法进行条件查询，将 entity 实例从数据库中查询出来，查询完成之后关闭持久化上下文。之后应用仍然维持着对这个实例的引用。那现在，这个实例就转换成游离态了，并且这个数据会被认为是旧数据。这个时候你可以放弃继续使用该实例并且让垃圾回收器将其回收。当然，你也可以继续使用该实例，之后调用 merge() 方法去保存你的更改。我们将会在之后的章节专门讨论 merging。</p>
<p>现在你应该基本理解了 entity 实例的状态以及它们的转换。我们的下一个主题是 <strong>持久化上下文</strong> ：一个非常重要的服务。</p>
<h4 id="持久化上下文"><a href="#持久化上下文" class="headerlink" title="持久化上下文"></a>持久化上下文</h4><p>在 Java 持久化应用中，每个 EntityManager 都有一个持久化上下文，当你调用 EntityManagerFactory#createEntityManager() 方法时就会创建一个持久化上下文。当你调用 EntityManager#close() 方法时就可以关闭它，在 Jpa 术语中这也被叫做应用程序托管（application-managed）持久化上下文；你的应用要在一个事务中定义持久化上下文的边界。</p>
<p>持久化上下文监控、管理着所有 entity 的持久态。它是 JPA 许多功能的核心。</p>
<p>持久化上下文让持久化引擎可以自动检测哪些数据被应用修改了。它通过监控实例可以自动或者在需要的时候将状态同步到数据库中。一个典型场景就是当一个事务结束后，存储在内存中的状态会通过执行 INSERT,UPDATE,DELETE 等 SQL 语句同步到数据库中。当然，状态由内存同步到数据库的操作也可能发生在其他时间。例如，Hibernate 也可能在查询之前将这些同步到数据库中。这会确保查询出来的是当前事务范围内的最新数据。</p>
<p>持久化上下文作为一级缓存，它会记住哪些 entity 实例在当前事务中被处理过。例如，当你让 Hibernate 用主键去查询数据时，它会第一时间检查当前事务的持久化上下文，如果 Hibernate 从持久化上下文中找到了当前正在查询的实例，那它就会返回这个实例，而不会去数据库中进行查询。连续调用 em.find(Item.class, ITEM_ID) 会得到相同的结果。</p>
<p>这个缓存会影响所有查询的结果，例如 javax.persistence.Query 接口中定义的查询方法。Hibernate 会读取 sql 的查询结果，然后将结果转换成 entity 实例。程序首先会通过主键在持久化上下文中进行查找。只有在找不到的情况下 Hibernate 才会从结果集中读取。Hibernate 会忽略任何结果集中的新数据，受数据库读已提交的隔离级别影响，实例最新的数据就在当前的持久化上下文中。</p>
<p>持久化上下文默认开启，并且不可关闭，它可以做到以下几种事情：</p>
<ul>
<li>在因为循环引用导致堆栈溢出的情况下持久层依然有效。</li>
<li>保证线程安全。同一个 entity 实例被多次编辑，入库的时候也不会线程产生问题。</li>
<li>同一个事务中，数据的更改对其他正在执行的代码是立即可见的。JPA 保证 entity 实例是可重复读的。</li>
</ul>
<p><strong>在同一个持久化上下文中</strong>，可以保证每个特定的数据库数据的映射都是唯一的。例如，当前数据 A 的实例叫 entityA ，程序再次查询 A 数据，将实例的取名叫 entityB,  Hibernate 会保证 entityA == entityB 和 entityA.getId().equals(entityB.getId()) 两个条件同时为 true。</p>
<p>这么做合理吗？在大部分应用中，这么做是最好的选择。在单线程的应用进行操作的过程中保证 entity 实例在内存中是唯一的可以提高缓存的利用率。然而在多线程的应用中，则会产生资源的相互竞争，从而造成资源浪费。不过，让每个线程都有自己单独的持久化上下文副本也是很简单的，同时增加了程序的拓展性。</p>
<p>entity 实例的生命周期以及持久化上下文的功能在一开始可能是比较难理解的。下面就让我们看下 <strong>脏数据检查</strong>，<strong>进行缓存</strong>以及<strong>如何保证 entity 唯一</strong>的实战代码。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>ORM</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-InnoDB索引详解</title>
    <url>/posts/b7cc2c3.html</url>
    <content><![CDATA[<h2 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h2><p><strong>索引的作用就是能够让我们快速的查到想要的数据</strong>。上一篇文章我们介绍了 Mysql 在内存中存储数据的单位<code>页</code>，Mysql 从磁盘加载数据的时候会在内存中创建以<code>页</code>为节点的双向链表，我们已经了解到在<code>页</code>中查找数据可以通过二分查找法快速检索到数据，但是要确定数据在哪个页中就要一个页一个页的查找（如果你对在页中查找数据的过程有疑问，请查看上一篇博客），这个逻辑显然是不合理的，因为 Mysql 是能够存储大量数据的，所以这个双向链表会很长查找速度会很慢。为了解决这个问题，Mysql 的开发者创建了索引这个功能来达到快速查找数据的目的。</p>
<span id="more"></span>

<h2 id="Mysql-InnoDB-中索引的实现"><a href="#Mysql-InnoDB-中索引的实现" class="headerlink" title="Mysql-InnoDB 中索引的实现"></a>Mysql-InnoDB 中索引的实现</h2><p>Mysql-InnoDB 中索引是使用 B+ 树来实现的，索引按照数据列不同分为<code>主键索引</code>和<code>二级索引</code>。</p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p><strong>为主键创建的索引叫做主键索引</strong>。主键索引并不是显式创建的，当你为一个表指定主键时 Mysql 会为这个字段自动创建索引。</p>
<h4 id="存储索引的数据结构"><a href="#存储索引的数据结构" class="headerlink" title="存储索引的数据结构"></a>存储索引的数据结构</h4><p>存储索引的数据结构与真实的数据一样都是<code>页</code>，但是存储的内容有以下几点不同：</p>
<ol>
<li>File Header 中 record_type = 1，普通数据 record_type = 0 （这样程序在读取数据的时候就知道当前页是存储的什么类型的数据）；</li>
<li>页中以单链表存储着每个页的主键最小值及其页的引用（内存地址），方便根据 id 找到对应的页；</li>
</ol>
<p>所以主键索引和真实的数据在内存中的关联关系如图：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201152114735.png" alt="image-20220201152114735" style="zoom:80%;" />

<p>例如你现在要查找数据的主键是 2 ，那么在索引页（页20）中根据 1 &lt; 2 &lt; 3 （索引页中存储着每个页中主键的最小值）这个条件就可以判断出数据在页 10 中，然后根据引用就可以进入到页 10 中查找数据，这样就不用遍历链表了。</p>
<p><strong>看到这里的同学可能会有两个疑问</strong>：</p>
<ol>
<li>为什么页号不是连续的？因为这是链表，使用的内存空间并不一定是连续的。</li>
<li>如果存储索引的页所需空间超过16k 了怎么办？那就再创建一个页就好了，存储索引的页与页之间的关联关系与存储数据页是一样的都是双向链表。</li>
</ol>
<p>因为存储索引的页也会创建页目录，所以你在根据主键查询数据的时候就可以先通过二分查找法在索引页中找到这条数据存储在哪个数据页中，然后再进入到数据页中通过二分查找法找到所在分组，再通过遍历分组中的链表找到真正需要的数据。（如果你对在页中查找数据的过程有疑问，请查看上一篇博客）。</p>
<p><strong>如果索引页有很多怎么办？</strong>它们也会形成一个双向链表，那查询起来岂不是也很慢？对的，所以我们可以对索引页再创建一个索引页的索引页，最后结构如下图所示：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201171000521.png" alt="image-20220201171000521" style="zoom:80%;" />

<h4 id="根据主键查询数据的流程"><a href="#根据主键查询数据的流程" class="headerlink" title="根据主键查询数据的流程"></a>根据主键查询数据的流程</h4><p>通过以上内容的讲解相信你已经明白索引的存储原理了，那如果根据主键查询数据，Mysql 是如何操作的呢？</p>
<p>就以上图为例来讲解：</p>
<p>首先，通过跟节点（索引页的索引页）来找到正在查询的主键在哪个索引页中，然后在索引页中就可以找到对应的数据在哪个数据页中，最后定位到数据所在的数据页就可以轻松找到数据了。</p>
<h4 id="索引-B-树的建立过程"><a href="#索引-B-树的建立过程" class="headerlink" title="索引 B+ 树的建立过程"></a>索引 B+ 树的建立过程</h4><p>以上内容重点都是在讲解为什么这么设计，这么设计有什么作用，但是却没有讲这颗 B+ 树是怎么建立的。我们将在这一小节进行讲解。</p>
<h5 id="创建根节点"><a href="#创建根节点" class="headerlink" title="创建根节点"></a>创建根节点</h5><p>当你创建一个空表时，Mysql 会自动为这个表创建一个没有数据的页，我们称这个页为根节点。</p>
<p><img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201173057982.png" alt="image-20220201173057982"></p>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>当有数据插入时并不会为其生成索引页，而是直接将真实的数据插入到根节点中。</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201173356114.png" alt="image-20220201173356114" style="zoom:80%;" />

<h5 id="创建索引页"><a href="#创建索引页" class="headerlink" title="创建索引页"></a>创建索引页</h5><p>当数据多到一个页不足以满足需求时，跟节点就会将数据复制到一个新创建的节点中，并对其进行页分裂（页分裂就是把一个页中的数据，按照从小到大的顺序分配到两个页中，这种情况出现在一个页已经装满了，但是还要保存新数据时发生，这样新数据就可以插入那个新分裂出来的页中了），然后将根节点作为索引页来保存索引。</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201174244639.png" alt="image-20220201174244639" style="zoom:80%;" />

<p>随着数据的增多，根据此规律就会逐渐形成一颗庞大的 B+ 树。</p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>除了主键索引以外的都叫二级索引。先说下二级索引的工作原理，二级索引的作用就是根据查询条件找到要查询数据的主键，然后再用主键去主键索引中查询数据。</p>
<p>例如我们现在有一张表，字段为：id(主键)、name、age。如果现在我们对 name 这个字段建立了一个二级索引那对应的 B+ 树应该如何表示呢？如下图：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201181429895.png" alt="image-20220201181429895" style="zoom:80%;" />

<p>与主键索引相比，二级索引主要有两点不同：</p>
<ol>
<li>索引页中保存的是 【索引列】+ 【主键】+【页号】；</li>
<li>数据页存储的是【索引列】+ 【主键】；</li>
</ol>
<p><strong>为什么索引页中要同时保存【索引列】和 【主键】呢？</strong>只留索引列不行吗？答案是不行，因为页中的数据是要按照从小到大的顺序排序的，比如说索引列的数值都一样，这个时候 Mysql 是不知道如何排序的，所以就加上了主键，这样如果索引列相同的话就可以用主键排序了，所以你可以简单的认为单个索引列的二级索引，其实是一种特殊的<code>联合索引</code>。</p>
<p><strong>数据查询流程</strong>：</p>
<p>查询数据的过程与主键索引是一样的，先根据 name 的数值在索引页找到具体的数据页，然后在数据页找到查询 name 对应的主键，拿到主键后再去主键索引 B+ 树中查找数据。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引就是用多个字段组成 B+ 树，例如仍然是用拥有 id(主键)、name、age 这三个字段的表进行举例。我们现在创建一个 name + age 两个字段的联合索引，索引结构如下图：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220201184118369.png" alt="image-20220201184118369" style="zoom:80%;" />

<p>如果你明白了二级索引的工作原理，那么这个联合索引你看下图应该就明白了</p>
<h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><p>这里有一个需要注意的点，就是数据是如何排序的。例如现在是 name + age 两个字段组成的联合索引，那么排序的时候就会先按照 name 进行排序，如果 name 相同再按照 age 进行排序。所以在查询数据的时候一定要包含 name 才会使用索引进行查询，如果单单使用 age 是不能用索引的，必须全表查询。这个就是<strong>最左匹配原则</strong> ，最主要的原因是 age 的顺序需要考虑 name 的大小，如果抛开 name 不谈，那 age 就是无序的，对一堆无序的数值我们是没办法用 B+ 树进行查找的，只能全表扫描。</p>
<h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h4><p>二级索引其实有一个问题，就是要先拿到数据的主键，然后再回到主键索引中去查询真正需要的数据，这个行为叫做<strong>回表</strong>。回表会在一定程度上影响性能，特别是在做范围查询的时候，因为需要多次回表查询。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如何解决回表导致的性能问题呢？我们现在都知道二级索引中会保存索引列的数值在 B+ 树上，那么这里就有一个优化查询速度的技巧，就是当你查询的所有数据都在二级索引中时，就会直接取二级索引中的数值返回给客户端，并不会做回表查询，因为没必要。例如你需要查询 name 和 age ，这两个字段的数据都在二级索引上，所以可以直接返回。</p>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><h4 id="空间占用"><a href="#空间占用" class="headerlink" title="空间占用"></a>空间占用</h4><p>因为索引会将数据直接存储在 B+ 树中，所以会占用内存空间，特别是字段很长的时候。<strong>所以索引列要尽可能的小。</strong></p>
<h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><ol>
<li>当你对索引列进行增删改的时候，Mysql 也需要对索引进行增删改的操作，在一定程度上会影响性能，<strong>所以索引字段应尽可能的少。</strong></li>
<li>当新数据的索引列不是最大的时候，Mysql 需要到索引树中去找到合适的位置去插入这条数据，有可能还会涉及页分裂等需要移动数据的操作，<strong>所以我们的索引列最好要自增，这样 Mysql 可以直接追加，而不用调整索引列的顺序。</strong></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-InnoDB缓存详解</title>
    <url>/posts/e7489af5.html</url>
    <content><![CDATA[<p>Mysql 的缓存叫做 Buffer Pool 它的主要作用就是将一些数据存储在内存中，当数据库需要访问的时候直接访问内存中的数据，而不用重新从磁盘中加载，减少磁盘 IO，提高系统运行效率。</p>
<span id="more"></span>

<h2 id="Buffer-Pool-的组成"><a href="#Buffer-Pool-的组成" class="headerlink" title="Buffer Pool 的组成"></a>Buffer Pool 的组成</h2><p>Buffer Pool 由两个部分组成，一个是<strong>数据页</strong>，就是被缓存的数据，数据是以页为单位进行缓存的。另一个叫<strong>控制信息</strong>，控制信息是保留页信息的数据结构，每缓存一个页都会生成对应的控制信息，控制信息包括页所属的表空间、页号、在 Buffer Pool 的地址等等。控制信息和数据页是一一对应的。</p>
<p>它们在 Buffer Pool 的位置是<strong>控制信息在前，数据页在后</strong>。位置布局如下图所示：</p>
<p><img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220204154312226.png" alt="image-20220204154312226"></p>
<h2 id="Buffer-Pool-的初始化"><a href="#Buffer-Pool-的初始化" class="headerlink" title="Buffer Pool 的初始化"></a>Buffer Pool 的初始化</h2><p>在 Mysql 启动的时候会向操作系统申请一片连续的内存空间，并且将整个 Buffer Pool 都用空的控制信息和页填满，等需要缓存数据的时候再填充数据（一开始就确定了能放多少个控制信息和页）。</p>
<h2 id="对数据进行管理"><a href="#对数据进行管理" class="headerlink" title="对数据进行管理"></a>对数据进行管理</h2><p>Buffer Pool 可以特别大，虽然默认才几百兆，但是只要你的内存足够大，可以将它设置为几百G，在这么大的内存空间中，如何知道哪些页是空的呢？要一个一个遍历吗？下面就让我们来看下如何解决这个问题 。</p>
<h3 id="如何知道哪些页是空的"><a href="#如何知道哪些页是空的" class="headerlink" title="如何知道哪些页是空的"></a>如何知道哪些页是空的</h3><p>其实 Buffer Pool 中设计了一个<strong>双向链表</strong>来解决这个问题。这个链表叫做 free 链表。Buffer Pool 会将空闲页对应的<strong>控制信息</strong>作为一个节点放到链表中。所以缓存数据的流程变为这样，首先从链表头拿到一个节点，通过节点找到空闲页，填充数据后将控制信息节点从链表中移除。</p>
<h3 id="如何知道要查询的页已经在缓存中了？"><a href="#如何知道要查询的页已经在缓存中了？" class="headerlink" title="如何知道要查询的页已经在缓存中了？"></a>如何知道要查询的页已经在缓存中了？</h3><p><strong>答案是 HashMap</strong> 。我们现在都知道，控制信息中保存着页的许多基础信息，其中有表空间和页号，如果你看过我之前的博客应该就可以知道表空间+页号可以确定唯一的一个页，也可以说是页的唯一索引，所以我们可以用表空间+页号作为 key，数据页作为 value，这样就可以快速判断要查询的页是否已经在缓存中了。</p>
<h3 id="如何知道哪些缓存中页的数据被修改了？"><a href="#如何知道哪些缓存中页的数据被修改了？" class="headerlink" title="如何知道哪些缓存中页的数据被修改了？"></a>如何知道哪些缓存中页的数据被修改了？</h3><p>我们都知道磁盘读写速度是很慢的，如果每次更改都等同步到磁盘后才算结束那性能会很低。同时 Buffer Pool 中的空间又可能特别大，如果每次先写入缓存然后异步的将所有数据都同步到磁盘中也不太现实。所以要找出一种解决办法，识别出哪些页的数据被修改，然后通过异步的方式将其同步到磁盘中，这样既能保证系统的性能，同时也能保证数据不会丢失。</p>
<p><strong>答案是链表！</strong>说实话这链表 Mysql 是玩明白了。Mysql 中设计了名为 <strong>flush 的双向链表</strong>。当有页中的数据被更改了，就将其对应的控制信息加入到 flush 链表中，之后再异步的更新到磁盘中。</p>
<h3 id="内存不够了怎么办？"><a href="#内存不够了怎么办？" class="headerlink" title="内存不够了怎么办？"></a>内存不够了怎么办？</h3><p>Mysql 使用的是 <strong>LRU 内存淘汰机制</strong>（最近最少使用原则）。创建一个链表，当有页被访问时就将对应的控制信息放到链表的头结点，当要淘汰某些页时从链表末尾进行移除。</p>
<p><strong>但是这会引发一个问题：劣币驱逐良币。</strong>当触发 <strong>Mysql 预读机制或者遇到全表扫描</strong>的时候，如果这么做会让预读出来的或者全表扫描的数据也都放在链表的头部，因为这部分数据可能特别多，这样有可能导致一些热点数据被挤到链表尾部，在内存不足时会被移除。</p>
<h4 id="对-LRU-进行分段"><a href="#对-LRU-进行分段" class="headerlink" title="对 LRU 进行分段"></a>对 LRU 进行分段</h4><p><strong>将一个 LRU链表分成两个部分</strong>。一个存储<strong>热数据</strong>，一个存储<strong>冷数据</strong>。</p>
<h5 id="Mysql-预读机制"><a href="#Mysql-预读机制" class="headerlink" title="Mysql 预读机制"></a>Mysql 预读机制</h5><p>通过 Mysql 预读机制获得的数据刚开始都加入到<strong>冷数据部分中</strong>，如果被访问一次就将这个数据移动到热数据链表中。</p>
<h5 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h5><p><strong>全表扫描的特点是放到冷数据链表中后会被短时间内多次访问</strong>（比如有两个筛选条件，将符合第一个条件的数据筛选出来后再用第二个条件进行筛选，这样就导致多次访问）。这时就不会将数据转移到热数据链表中，会在控制信息中记录访问时间，如果间隔大于一定范围才会移动到热数据链表中。就是为了防止全表扫描短时间频繁访问后就再也不用的特点。</p>
<h4 id="LRU-方案性能问题"><a href="#LRU-方案性能问题" class="headerlink" title="LRU 方案性能问题"></a>LRU 方案性能问题</h4><p>热数据访问特别频繁，总是将其移动到链表头部效率很低，怎么办？</p>
<p>解决方案是：热数据链表前 1/4 的数据被访问时不会将其移动到链表头部，因为其“够热”，这样就能减少对链表的操作，提高性能。</p>
<h2 id="提高缓存读写性能"><a href="#提高缓存读写性能" class="headerlink" title="提高缓存读写性能"></a>提高缓存读写性能</h2><p><strong>创建多个 Buffer Pool 实例</strong>，建议 1G 以上时使用。因为处理链表等工作都需要加锁。多个实例可以提高并发处理能力.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-InnoDB页详解</title>
    <url>/posts/6d95a3c4.html</url>
    <content><![CDATA[<h2 id="页的作用"><a href="#页的作用" class="headerlink" title="页的作用"></a>页的作用</h2><p>什么是页？页是 Mysql 从磁盘中加载数据的最小单位。页的大小为 16 kb。</p>
<p>为什么要按页加载数据呢？首先我们都知道磁盘 IO 是比较慢的，如果每查一条数据都要从磁盘中读取数据的话性能是很差的。所以当查询一条数据的时候 Mysql 会从磁盘中将与这条数据相近的数据都加载到内存中，这样可以大幅度提高性能。</p>
<span id="more"></span>

<h2 id="页是如何存储数据的"><a href="#页是如何存储数据的" class="headerlink" title="页是如何存储数据的"></a>页是如何存储数据的</h2><p> 页是使用<strong>单链表</strong>来存储数据的，并且数据是按照<strong>主键</strong>从小到大的顺序排列的。同时为了方便管理数据 Mysql 会在页中自动生成两条伪数据 Infimum 和 Supremum。Infimum 代表最小值，比真实数据的最小值要小， Supremum 代表最大值，比真实数据的最大值要大。如图：</p>
<img src="https://s2.loli.net/2022/01/16/m2UuVw6TJj3n4DN.png" style="zoom:50%;" />

<p><strong>下面我们有一个疑问，下一条数据的<code>引用</code>是怎么存储在本条数据中的？</strong></p>
<p>其实，每条记录主要分为两个部分，一个部分就是用来<strong>记录真实数据的</strong>，另一个部分是用来<strong>记录一些辅助信息的</strong>。如图：</p>
<img src="https://s2.loli.net/2022/01/16/4oQcxBLRvNiXpVn.png" alt="image-20220116151922425" style="zoom:67%;" />



<p>辅助信息这部分有很多用来记录信息的字段，而用来记录下一条记录的引用的字段叫做 <strong>next_record</strong>。所以数据之间的连接关系可以补充为下图这样：</p>
<img src="https://s2.loli.net/2022/01/16/qgZujyKwhvsGmVR.png" alt="image-20220116152755131" style="zoom:50%;" />

<p>同时，页中的数据并不是一开始就全部被填充进去的，因为要形成链表所以数据是一条一条插入的，而这个时候就涉及到内存分配的问题了，Mysql 将存储真实数据的部分叫做 <code>User Records</code> 然而 User Records 每次插入数据的时候都需要到 <code>Free Space</code> 去申请，这时 Free Space 会将一部分内存分配给 User Records 让其存储数据，当 Free Space 用完时就需要再创建一个页了。</p>
<p>内存分配流程如下图：</p>
<img src="https://s2.loli.net/2022/01/16/yv8cYiJaUhlwTdR.png" alt="image-20220116162143889" style="zoom:57%;" />

<p>所以，以我们目前的知识可以知道页的布局如下：</p>
<img src="https://s2.loli.net/2022/01/16/TAygI59sGi3tXLE.png" alt="image-20220116160339069" style="zoom:60%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其实这里我有一个疑问，为什么要设计 Free Space 这个功能呢？就只有 User Records 不行吗？通过 User Records 的剩余空间是否可以插入下一条数据来判断是否需要创建一个新的页不行吗？可惜我还没有找到答案 o(╥﹏╥)o</span><br></pre></td></tr></table></figure>

<p>现在我们都知道页中是通过单链表这种数据结构来存储数据的了，你可能会问，如果数据量很大，链表的查询速度会很慢，Mysql 是如何解决这种问题的呢？</p>
<h2 id="优化页的查询速度"><a href="#优化页的查询速度" class="headerlink" title="优化页的查询速度"></a>优化页的查询速度</h2><h3 id="Infimum-和-Supremum"><a href="#Infimum-和-Supremum" class="headerlink" title="Infimum 和 Supremum"></a>Infimum 和 Supremum</h3><p>因为页中的数据是按照主键从小到大的顺序排列的，所以我们就能够很快的通过 Supremum 判断出要查找的数据是否在当前页中，如果不在就会直接跳过去下一个页中去查找，</p>
<p>例如：Supremum 是 10 ，Supremum 是 80，但是你查的数据的 id = 100 ,那明显就不是在这个页中，需要到下一个页中去查找。而页与页的关联关系存储在 <strong>File Header</strong> 中如图：</p>
<p><img src="https://s2.loli.net/2022/01/16/jo1xQOkR9t4mcFe.png" alt="image-20220116164123006"></p>
<h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>通过以上方法虽然能将查找的数据锁定在一个页中，但是一个页可以存好多数据呀，那查找起来不是也很慢？为了解决这个问题，Mysql 创建了 Page Directory 页目录这个功能，这个功能的主要思想就是将链表中的数据进行分组，每个组最多只存储 8 条数据（这里有个例外，最小记录的分组只会有一条数据），然后按照从大到小的顺序将每个组有多少条记录的信息汇集在一起，然后通过对比主键的大小就可以将目标数据锁定在某个分组中了，因为分组中的数据很少，所以即使是遍历一次也很快，这就解决了链表查询速度慢的问题了。</p>
<p>详细介绍页目录之前先介绍一下 <code>n_owned</code>这个字段，每条记录的<strong>辅助信息</strong>部分都维护一个 <code>n_owned</code> 字段，这个字段表示当前这个组有多少条数据，Infimum 的 n_owned 总是 1 ，而每组最大值的 n_owned 字段维护着这个组数据的总数目。而 Mysql 会将每个组的最大数据的引用用数组按照分组的顺序统一维护起来，并将数据中的元素称为槽。</p>
<p>如下图，总共有五条记录，它们被 Mysql 分成两组，<u>最小记录</u> 总是被单独分一组所以它的 n_owned 是 1，剩下的 <u>记录1、2、3 及最大记录</u>四条记录被分为一组，所以第二组的最大值 Supremum 中的 n_owned 的数值是4。</p>
<img src="https://s2.loli.net/2022/01/16/JmVZt469NpCI52q.png" alt="image-20220116213753322" style="zoom:67%;" />

<p>因为为了方便举例子所以我们目前只有两个分组，实际上分组可能有成千上万甚至更多，当我们要在一个页中查找数据时就可以对页目录用<strong>二分查找法进行查找</strong>，每次取到中间的槽然后根据引用找到对应的数据并用主键进行比较，这样就可以很快的将数据锁定在某个数据分组中，而我们都知道每个组中最多有8条数据，所以即使都遍历一遍也不会很慢。</p>
<p>到这里我们就又找到了一块拼图，可以将页的结构再完善一下，如图：</p>
<img src="https://s2.loli.net/2022/01/16/Levo56ZiCRqtMg3.png" alt="image-20220116214517277" style="zoom:67%;" />

<p>说完了数据查询，但是数据库不只是查询数据的，它也可以对数据进行更改，并且将数据同步到磁盘的最小单位也是页，但是如果同步到一半突然断电了怎么办？如果不增加验证的措施可能会录入不完整的数据，下面我们就来看下 Mysql 如何解决这个问题。</p>
<h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>为了检验一个页中的数据是否完整的同步到磁盘中了，Mysql 在每个页中都增加了 File Trailer 部分。在数据开始同步前，Mysql 会针对页数据生成一个校验码，这个校验码在 File Header 和 File Trailer 中各存一份，当一个页的数据同步完成后，数据首部和尾部的校验码如果一致就说明数据同步成功，否则就代表失败。</p>
<p>我们在页结构中补充上这一部分，如图：</p>
<img src="https://s2.loli.net/2022/01/16/LjgPYlQzfkKnqFy.png" alt="image-20220116215711976" style="zoom:67%;" />

<p>当然 Page Header 中不只存储着校验码，它还存储着一些其他的状态信息，例如本页中存储了多少条记录，第一条记录的内存地址，总共有多少个槽等等这些信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在学习页的相关知识时也在网上看了很多同类型的博客，他们都有一个共同的问题就是大量罗列参数。好像学习页就是要记住每一个参数一样，我对此有不同的观点，如果你看到这里你可能会发现，我并没有把参数都罗列出来然后一个一个解释，甚至很多参数我都没有介绍，因为我们真正要学的不是参数，而是它的设计思想，比如如何优化链表查询，如何验证数据是否完整等等，而具体的参数你可以在需要的时候在网上查一下就好了，没必要死记硬背，这样反而让学习别的枯燥、痛苦。毕竟写代码也不是闭卷考试对吧。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中byte转int为什么要使用&amp;0xFF</title>
    <url>/posts/1d17d658.html</url>
    <content><![CDATA[<p>在 Java 中将十六进制 byte 转成 int 时要使用 &amp;0xFF 操作这是为什么呢？这是因为十六进制的范围是 0x00~0x3FF 没有负数，而 int 的取值范围是包含负数的，所以直接将 byte 强转成 int 可能会得到错误的数值。同时操作系统存储的是二进制原码进行补码后的数值, 所以只有通过 &amp;0xFF 操作才能得到正确的数值。</p>
<span id="more"></span>

<p>至于为什么就要先知道什么是补码。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>下图以 -7 为例子展示了补码是如何计算的，简单说 -7 在计算机存储的二进制数据其实不是 <code>10000111</code> 而是 <code>11111001</code> 。<strong>但是这个流程值针对负数的，正数无论是反码还是补码都是一样的。</strong></p>
<p><img src="https://s2.loli.net/2022/01/03/oAWgmL3xRZ1QODh.png" alt="image-20220103151025334"></p>
<p>ps: 这里补充一个基础知识，原码其实是由两部分组成的，如下图最高位和数值位组成，因为二进制只能存储 0、1所以没有办法用正负号表示数值的正负，所以采用了这种办法。</p>
<p><img src="https://s2.loli.net/2022/01/03/BW45N7Hc2GQogJ8.png" alt="image-20220103151943112"></p>
<h2 id="为什么要用补码"><a href="#为什么要用补码" class="headerlink" title="为什么要用补码"></a>为什么要用补码</h2><p>使用补码是为了简化计算机底层的设计。因为我们人可以很清楚的知道最高位是符号位，但是对于计算机基础电路设计来说判别第一位是符号位是非常难和复杂的事情。所以人们为了让实现变得简单就想让符号位也参与运算，并且只保留加法，我们知道减法相当于加上一个负数。</p>
<p>例如：</p>
<p><code>1 - 1 = 1 + （ -1） = 0</code></p>
<h3 id="原码计算"><a href="#原码计算" class="headerlink" title="原码计算"></a>原码计算</h3><p>我们都知道上面的等式是成立的，但是如果用<strong>原码</strong>直接进行运算会得到什么结果呢？</p>
<p><code>0000 0001 + 1000 0001 = 1000 0010 = -2 </code></p>
<p>得到了错误的结果。为了解决这个问题创建了反码。</p>
<h3 id="反码计算"><a href="#反码计算" class="headerlink" title="反码计算"></a>反码计算</h3><p>原码：0000 0001 + 1000 0001 = 反码：0000 0001 + 1111 1110 =  反码：1111 1111  = 原码： 1000 0000 = -0 。</p>
<p>根据以上等式我们看出来，使用反码进行计算可以得到正确的结果，但是虽然人们可以理解 +0 和 -0 是一样的但是这会引发两个问题 ，一方面为 0 标注正负是没有任何意义的，另一方面会出现 0000 0000 和 1000 0000 两个编码都表示 0 的现象，这会增加计算机设计的复杂度而且没有必要。所以为了解决这个问题 设计出了<strong>补码</strong>。</p>
<h3 id="补码计算"><a href="#补码计算" class="headerlink" title="补码计算"></a>补码计算</h3><p>原码：0000 0001 + 1000 0001 = 补码：0000 0001 + 1111 1111  =  补码： 0000 0000 = 原码：0000 0000 = 0 。</p>
<p>这样就解决了所有的问题，可以轻松愉快的带入符号进行计算了。</p>
<h2 id="amp-0xFF-的作用"><a href="#amp-0xFF-的作用" class="headerlink" title="&amp;0xFF 的作用"></a>&amp;0xFF 的作用</h2><p>主要作用就是保证补码的完整性。</p>
<p>因为 byte 是一个字节而 int 是四个字节，所以 byte 转 int 需要进行数据扩展。Java 采用的是<strong>符号位扩展</strong>。以 -127 为例：</p>
<p>-127 的补码为 <code>10000001</code>, 数据扩展之后是 <code>11111111 11111111 11111111 10000001</code> 这个二进制数值明显不对，所以为了得到正确的结果让其和 0xFF 进行与运算将补位的 1 全部换成 0 最后得到 <code>00000000 00000000 00000000 10000001</code> 这个就是我们需要的结果了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-InnoDB表空间详解</title>
    <url>/posts/720913d1.html</url>
    <content><![CDATA[<h2 id="什么是表空间"><a href="#什么是表空间" class="headerlink" title="什么是表空间"></a>什么是表空间</h2><p>表空间是 Mysql 的一个抽象概念，在你新建一个表的时候，Mysql （5.7 + 版本）会为这个表创建一个后缀为 ibd 的文件，这个文件的名字就是表空间，构成表空间的最小单位就是页，所以表空间是实际存储索引和用户数据的地方。因为一个页最多 16k 大小，所以一个表空间拥有页的数量会特别巨大，为了更方便的对页进行管理，Mysql 的作者发明了<code>区</code>的概念。</p>
<span id="more"></span>

<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>区的作用就是为了更方便的管理表空间中的页，表空间会被划分成很多连续的区，一个区由 64 个页构成，大小为 1M。256个区被划分为一组，每组的第一个区的前几个页的类型是固定了，为了方便存储一些全局数据，后续会展开讲解。</p>
<h3 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h3><ul>
<li>空闲的区：表示区内没有存储任何数据。</li>
<li>有剩余空间的碎片区：已经存有数据，但是还可以继续存储数据的区。</li>
<li>没有剩余空间的碎片区：已经不能继续存储数据了。</li>
<li>附属于某个段的区：这个后面详细讲。</li>
</ul>
<h3 id="存储区的数据结构"><a href="#存储区的数据结构" class="headerlink" title="存储区的数据结构"></a>存储区的数据结构</h3><p>为了方便对区进行操作，Mysql 的作者为其设计了一个特殊的数据结构，名字叫 XDES Entry。总共由四个部分组成，如图：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220203112524580.png" alt="image-20220203112524580" style="zoom:67%;" />

<p>上一节我们说<code>区</code>分了四个种类，所以在写入数据的时候要先写入到<code>有剩余空间的碎片区</code>中，如果已经没有碎片区可以用了，那再去<code>空闲的区</code>申请空间。那现在问题来了，<strong>表空间这么大如何快速找到不同种类的区呢？</strong></p>
<h3 id="如何快速找到不同种类的区"><a href="#如何快速找到不同种类的区" class="headerlink" title="如何快速找到不同种类的区"></a>如何快速找到不同种类的区</h3><p>答案是利用 XDES Entry 的 List Node 字段，<strong>表空间会利用这个字段形成三个表空间的链表</strong>，这三个链表的类型分别是：Free (空闲的区)、FreeFrag （有空闲的碎片区）、FullFrag （没有空闲的碎片区）。当要写入数据的时候就先找到 FreeFrag 类型的区，如果将这个区的剩余空间都用完了，就将这个区挂载到 FullFrag 链表中，然后从 Free 中拿到一个节点挂载到 FreeFrag 中继续写入数据。链表的样子大概如下图所示：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220203115239807.png" alt="image-20220203115239807" style="zoom:70%;" />

<p><strong>现在问题又来了，如何找到这三种类型的链表呢？</strong> </p>
<h4 id="如何找到不同类型的链表"><a href="#如何找到不同类型的链表" class="headerlink" title="如何找到不同类型的链表"></a>如何找到不同类型的链表</h4><p>为了解决这个问题，Mysql 的作者设计了名为 LisiBaseNode 的数据结构，这个数据结构存储着链表的<strong>头结点、尾结点和链表总共有多少个节点的信息。</strong>并将 LisiBaseNode <strong>存储在表空间的第一个页中</strong>，这个页的页号为 0 ，类型为 FSP_HDR，也是表空间分组中的第一组的第一个区的第一个页。这样就可以在表空间中快速找到不同类型的区啦~~。</p>
<h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>段是由区和单独的页构成的。<strong>段的主要作用就是为了增加表空间读写数据的性能</strong>，因为表空间可能特别大，所以区与区之间可能距离特别远，当 Mysql 批量操作数据的时候就需要跨越很远的距离去查找数据，这种情况叫做<code>随机 IO</code>这是很慢的，而段的特点是会分配一段连续的内存空间在这段空间内再创建区，这样区与区的距离就不会特别远，可以达到<code>顺序 IO</code>的效果，可以极大的增加数据库的性能。</p>
<p>我们都知道 B+ 树有叶子节点和非叶子节点的区别，为了进一步增加数据库性能，<strong>就让叶子节点和非叶子节点分别创建各自的段。</strong></p>
<p><strong>如何区分一个段是属于叶子节点还是非叶子节点的呢？</strong>其实<code>段</code>是由专门的页结构存储的，而这个页的 Page Header 就会标注清楚哪些段是叶子节点的，哪些是非叶子节点的。</p>
<h3 id="存储段的数据结构"><a href="#存储段的数据结构" class="headerlink" title="存储段的数据结构"></a>存储段的数据结构</h3><p>为了方便对<code>段</code>进行管理，Mysql 的作者设计了一个特殊的数据结构用来存储段的信息，这个数据结构叫做 INODE ENtity ，结构如下图所示：</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220203124353554.png" alt="image-20220203124353554" style="zoom:67%;" />

<p>下面对结构进行详细的解释。</p>
<h4 id="List-Base-Node"><a href="#List-Base-Node" class="headerlink" title="List Base Node"></a>List Base Node</h4><p>为了能够快速分辨哪些段还可以继续写入数据，哪些段已经满了，Mysql 的设计者也对段进行了与区相同的分类，分为 Free(空闲)、NotFull(有一些数据，但是还可以继续写入)、Full(已经完全满了)。同样为了方便快速定位不同类型的链表设计者直接将三种类型链表的 ListBaseNode 节点放在了段的数据结构中。</p>
<h4 id="Fragement-Array-Entry"><a href="#Fragement-Array-Entry" class="headerlink" title="Fragement Array Entry"></a>Fragement Array Entry</h4><p>你可能有因为，为什么段中还直接保存页呀？不是应该只保存区吗？<strong>这么做是为了更好的利用存储空间</strong>，段默认会分配 1M 大小，如果不够可以继续增加，但是如果你的数据特别少也用 1M 是不是就太浪费空间了呀？所以，设计者们提出了<code>碎片区</code>的概念，这个区内的页可以属于任何段，只有一个段占用的碎片区达到一定大小的时候才会分配一个完整区给这个段，这样可以更高效的利用存储空间。</p>
<h3 id="INODE-ENtity-存储在什么地方"><a href="#INODE-ENtity-存储在什么地方" class="headerlink" title="INODE ENtity 存储在什么地方"></a>INODE ENtity 存储在什么地方</h3><p> INODE ENtity  也存储在页中，这个页位于表空间第一个分组的第一个区的第三个页中存储着所有 INODE ENtity 的基础信息（也可能是链表，因为有可能一个页无法存储所有段的基础信息）。这个页的类型为 INODE。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便大家理解，下面用一个图来表示表空间、区分组、区、段这些信息是如何存储的。</p>
<img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220203130935197.png" alt="image-20220203130935197" style="zoom:67%;" />

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/posts/4eb3381c.html</url>
    <content><![CDATA[<p>在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。 但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。 当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。</p>
<span id="more"></span>

<h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。 但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。 当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。</p>
<h2 id="2-常用分布式锁"><a href="#2-常用分布式锁" class="headerlink" title="2. 常用分布式锁"></a>2. 常用分布式锁</h2><h3 id="2-1-Redis实现分布式锁"><a href="#2-1-Redis实现分布式锁" class="headerlink" title="2.1 Redis实现分布式锁"></a>2.1 Redis实现分布式锁</h3><h4 id="2-1-1-Redis实现分布式锁原理"><a href="#2-1-1-Redis实现分布式锁原理" class="headerlink" title="2.1.1 Redis实现分布式锁原理"></a>2.1.1 Redis实现分布式锁原理</h4><p>Redis实现分布式锁主要是使用Redis提供的setnx命令，setnx 是『SET if Not eXists』(如果不存在，则 SET)的简写。 命令格式：SETNX key value；使用：只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。返回值：命令在设置成功时返回 1 ，设置失败时返回 0 ，Redis保证setnx的原子性，所以如果setnx返回1就说明获取到锁，如果0就说明获取锁失败。</p>
<h4 id="2-1-2-Redis实现分布式锁潜在问题"><a href="#2-1-2-Redis实现分布式锁潜在问题" class="headerlink" title="2.1.2 Redis实现分布式锁潜在问题"></a>2.1.2 Redis实现分布式锁潜在问题</h4><p>主要问题就是<strong>超时</strong>，例如当业务执行时间大于key的过期时间就可能产生并发问题，同时也可能将其他线程持有的锁误删。</p>
<h4 id="2-1-2-超时问题解决方案"><a href="#2-1-2-超时问题解决方案" class="headerlink" title="2.1.2 超时问题解决方案"></a>2.1.2 超时问题解决方案</h4><p>解决方案就是<strong>自动续期</strong>，当线程成功获得锁后就开启一个WatchDog监听当前线程，如果key超时之前不能完成业务逻辑那就将key的过期时间延长，同时如果持有锁的服务宕机就不自动续期，让Redis将key删除，当然这个功能已经有现成的实现方式了，就是<strong>Redisson</strong>。</p>
<h4 id="2-1-3-利用Redisson实现Redis分布式锁"><a href="#2-1-3-利用Redisson实现Redis分布式锁" class="headerlink" title="2.1.3 利用Redisson实现Redis分布式锁"></a>2.1.3 利用Redisson实现Redis分布式锁</h4><p>首先引入Redisson依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.15</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	<span class="comment">//添加Redis配置信息</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        redissonClient = Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread4 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">        myThread3.start();</span><br><span class="line">        myThread4.start();</span><br><span class="line"></span><br><span class="line">        myThread1.join();</span><br><span class="line">        myThread2.join();</span><br><span class="line">        myThread3.join();</span><br><span class="line">        myThread4.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="comment">//初始化锁对象</span></span><br><span class="line">            RLock watchDogLock = redissonClient.getLock(<span class="string">&quot;watchDogLock&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            	<span class="comment">//利用Redisson的API成功获取锁时Redisson会自动启动WatchDog监听当前线程，底层实现是通过Lua脚本。</span></span><br><span class="line">                <span class="keyword">boolean</span> success = watchDogLock.tryLock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 是否成功获取锁：&quot;</span> + success);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行业务逻辑&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 业务执行成功，进行解锁&quot;</span>);</span><br><span class="line">                        watchDogLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Zookeeper实现分布式锁"><a href="#2-2-Zookeeper实现分布式锁" class="headerlink" title="2.2 Zookeeper实现分布式锁"></a>2.2 Zookeeper实现分布式锁</h3><h4 id="2-2-1-Zookeeper实现分布式锁原理"><a href="#2-2-1-Zookeeper实现分布式锁原理" class="headerlink" title="2.2.1  Zookeeper实现分布式锁原理"></a>2.2.1  Zookeeper实现分布式锁原理</h4><ol>
<li><strong>数据结构</strong>：Zookeeper内部维护一个树形的数据结构，用户可以根据其提供的Api创建或者删除节点，并且Zookeeper会为每个节点生成一个不会重复并且根据创建顺序由小到大排列的序号。</li>
<li><strong>永久节点和临时节点</strong>：永久节点除非手动删除，不然不会自动删除；临时节点会在客户端断开一段时间后自动删除，如果客户端没有断开链接，或者没有手动删除就会一直存在，同时永久节点下面可以创建临时节点，但是临时节点下面不能创建永久节点。</li>
<li><strong>Watch机制</strong>：子节点可以在上一个节点创建一个监听器，同时传入一个回调方法，当前一个节点改变时（例如，删除，更新）会收到通知，并且执行回调方法。</li>
</ol>
<p>就是因为临时节点的特性，所以Zookeeper不会遇到和Redis相同的问题，如果客户端运行正常运行就不会删除临时节点，也就不会释放锁，如果客户端宕机那临时节点就会在客户端断开一段时间后自动删除。</p>
<h4 id="2-2-2-Zookeeper分布式锁工作流程"><a href="#2-2-2-Zookeeper分布式锁工作流程" class="headerlink" title="2.2.2 Zookeeper分布式锁工作流程"></a>2.2.2 Zookeeper分布式锁工作流程</h4><ol>
<li>当需要对资源进行加锁时，实际上就是在父节点之下创建一个临时顺序节点。</li>
<li>客户端A来对资源加锁，首先判断当前创建的节点是否为最小节点，如果是，那么加锁成功，后续加锁线程阻塞等待。</li>
<li>此时，客户端B也来尝试加锁，由于客户端A已经加锁成功，所以客户端B发现自己的节点并不是最小节点，就会去取到上一个节点，并且对上一节点注册监听。</li>
<li>当客户端A操作完成，释放锁的操作就是删除这个节点，这样就可以触发监听事件，客户端B就会得到通知，同样，客户端B判断自己是否为最小节点，如果是，那么则加锁成功。</li>
</ol>
<h4 id="2-2-3-代码示例"><a href="#2-2-3-代码示例" class="headerlink" title="2.2.3 代码示例"></a>2.2.3 代码示例</h4><p>代码使用了Curator包，这个包封装了底层Zookeeper的操作，使用起来更加方便，可以有效减少样板代码。</p>
<p>首先引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CuratorFramework ZK_CLIENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	<span class="comment">//初始化Zookeeper配置</span></span><br><span class="line">        String zkServerAddress = <span class="string">&quot;127.0.0.1:12181&quot;</span>;</span><br><span class="line">        ExponentialBackoffRetry retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        ZK_CLIENT = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerAddress)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">        ZK_CLIENT.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_PATH = <span class="string">&quot;/myLock&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InterProcessMutex LOCK = <span class="keyword">new</span> InterProcessMutex(ZK_CLIENT, LOCK_PATH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread myThread4 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread2.start();</span><br><span class="line">        myThread3.start();</span><br><span class="line">        myThread4.start();</span><br><span class="line"></span><br><span class="line">        myThread1.join();</span><br><span class="line">        myThread2.join();</span><br><span class="line">        myThread3.join();</span><br><span class="line">        myThread4.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">//加锁</span></span><br><span class="line">                    LOCK.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                        <span class="comment">//解锁</span></span><br><span class="line">                        LOCK.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>Redis和Zookeeper都能够实现分布式锁，但是他们之间有相同点和不同点，使用的时候需要根据需求来选择。<br><strong>相同点</strong>：由于工具封装的都比较好，实现起来都很简单。</p>
<p><strong>不同点</strong>：</p>
<ol>
<li><strong>可靠性</strong>：Zookeeper可靠性高于Redis，因为Zookeeper的实现方式而言，本身就是保证数据一致性的，可靠性更高，而Redis不是数据强一致性的，某些极端场景下还是可能会存在问题。</li>
<li><strong>性能</strong>：Redis性能比Zookeeper好，因为Zookeeper需要频繁创建和删除节点，性能略低。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-submodule 统一配置简明教程</title>
    <url>/posts/b62a4af1.html</url>
    <content><![CDATA[<p>随着公司的不断发展，为了提高系统的容灾能力以及功能模块的复用程度，不断有更多的项目引入了微服务的概念，但是随着业务复杂度不断的上升，拆分模块的数量也越来越多，统一管理众多模块的配置文件的需求就应运而生。</p>
<p>git-submodule 是 git 提供的一个功能模块， 它允许一个 git 仓库，作为另一个 git 仓库的子目录，并且保持父项目和子项目相互独立。通过这个功能模块我们就可以让多个项目同时使用一个 git 仓库的代码进行开发。由此可以实现配置的统一管理。</p>
<p>之所以选用 git-submodule 是因为它足够简单，学习成本低；侵入性小，不需要系统做很多更改。但是所有事情都有两面，他也有一些缺点，比如功能单一，不够灵活。虽然它有这些缺点，但是对于使用场景比较单间的项目就足够了，并不是功能越多越好，适合的才是最好的。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着公司的不断发展，为了提高系统的容灾能力以及功能模块的复用程度，不断有更多的项目引入了微服务的概念，但是随着业务复杂度不断的上升，拆分模块的数量也越来越多，统一管理众多模块的配置文件的需求就应运而生。</p>
<h2 id="为什么选用-git-submodule"><a href="#为什么选用-git-submodule" class="headerlink" title="为什么选用 git-submodule"></a>为什么选用 git-submodule</h2><p>git-submodule 是 git 提供的一个功能模块， 它允许一个 git 仓库，作为另一个 git 仓库的子目录，并且保持父项目和子项目相互独立。通过这个功能模块我们就可以让多个项目同时使用一个 git 仓库的代码进行开发。由此可以实现配置的统一管理。</p>
<p>之所以选用 git-submodule 是因为它足够简单，学习成本低；侵入性小，不需要系统做很多更改。但是所有事情都有两面，他也有一些缺点，比如功能单一，不够灵活。虽然它有这些缺点，但是对于使用场景比较单间的项目就足够了，并不是功能越多越好，适合的才是最好的。</p>
<h2 id="如果你需要集成-git-submodule-应该如何做"><a href="#如果你需要集成-git-submodule-应该如何做" class="headerlink" title="如果你需要集成  git-submodule 应该如何做"></a>如果你需要集成  git-submodule 应该如何做</h2><h3 id="检查项目中的同名模块"><a href="#检查项目中的同名模块" class="headerlink" title="检查项目中的同名模块"></a>检查项目中的同名模块</h3><p>  git-submodule 是不允许两个或两个以上的模块存在相同名字的情况发生，所以要先做检查。</p>
<h3 id="使用-git-submodule-添加子模块"><a href="#使用-git-submodule-添加子模块" class="headerlink" title="使用  git-submodule 添加子模块"></a>使用  git-submodule 添加子模块</h3><p>执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add -b $&#123;分支名字&#125; $&#123;git仓库地址&#125;</span><br></pre></td></tr></table></figure>

<p>命令详细解析：</p>
<ul>
<li>git ：调用 git 可执行程序；</li>
<li>submodule add ： 添加  git-submodule 子模块；</li>
<li>-b ${分支名字}：将子模块的哪个分支作为当前项目的字目录，如果不写默认是主模块；</li>
<li>${git仓库地址} ：子模块项目地址；</li>
</ul>
<p>以现货为例，最终命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add -b prod/dev http://[xxx].git</span><br></pre></td></tr></table></figure>

<h3 id="拉取子模块代码"><a href="#拉取子模块代码" class="headerlink" title="拉取子模块代码"></a>拉取子模块代码</h3><p>当执行完 3.2 步骤之后我们会发现项目中多个一个空文件夹，没错是它空的， submodule add 命令不会直接将代码也拉取下来，第一次需要我们主动些。</p>
<p>执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<p>执行完这条命令后子模块的代码就被拉取下来了。</p>
<p>如果之后子模块代码有更新了怎么办？当然再执行一次上面的命令就可以了，不过这样略显麻烦，git 当然不会有这么智障的操作，如果子模块有更新了，我们在主模块使用 <strong>git pull</strong> 也应该可以将最新代码拉取下拉，为此，需要你执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config submodule.recurse true</span><br></pre></td></tr></table></figure>

<p>这样，每次在主模块执行 git pull 的时候，都会去拉取子模块的最新代码。</p>
<h3 id="切换子模块分支"><a href="#切换子模块分支" class="headerlink" title="切换子模块分支"></a>切换子模块分支</h3><p>这一步是可选的，是否需要这么做需要你看看你的子模块是否成功关联了对应分支。</p>
<p>可使用如下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>会显示子模块目前所在分支，如果出现  <strong>HEAD detached from</strong> 等提示语就表示没有成功关联到指定分支，那么你需要按照下面的步骤进行操作。</p>
<p>这一步可能让你迷惑，什么？在 3.2 步不是已经指定子模块的分支了吗？对没错，你是指定了，但是他只是让主模块保存了指定分支的最后一次提交的 commit id。并没有真正关联到对应模块。</p>
<p>这个时候就需要你自己切换分支，可执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout xxx</span><br></pre></td></tr></table></figure>

<p>xxx 为要切换分支的名字，当然你用各种 git 图形化工具操作也是一样的。</p>
<h2 id="如果你要-clone-一个集成了-git-submodule-的项目应该如何做"><a href="#如果你要-clone-一个集成了-git-submodule-的项目应该如何做" class="headerlink" title="如果你要 clone 一个集成了  git-submodule 的项目应该如何做"></a>如果你要 clone 一个集成了  git-submodule 的项目应该如何做</h2><p>推荐使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules $&#123;git仓库地址&#125;</span><br></pre></td></tr></table></figure>

<p>在 clone 的时候加上 –recurse-submodules 参数，这样就会将子模块的内容都拉取下来。</p>
<p>然后执行 3.4 步骤的操作，选取子模块分支。</p>
<p>再执行如下命令，保证每次 git pull 的时候都能获取子模块最新代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config submodule.recurse true</span><br></pre></td></tr></table></figure>

<h2 id="在子模块上提交代码"><a href="#在子模块上提交代码" class="headerlink" title="在子模块上提交代码"></a>在子模块上提交代码</h2><p>子模块就跟其他 git 项目一样，你是可以直接更改代码并提交的，但是这里有一点需要注意，就是如果你在子模块上提交了代码，那么在主模块上也要提交一次，也就是说<strong>要提交两次代码</strong>，这是至关重要的，如果你没有这么做，有可能会让其他人的子模块无法正常工作。</p>
<p>例如你在子模块提交代码后，在主模块查看 git 状态时会有如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modified:   xxx（模块名） (new commits)</span><br></pre></td></tr></table></figure>

<p>你必须要将这个代码提交到主模块的 git 仓库，这个更改其实是记录着子模块最新提交的 commit id 。用来做版本管理的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果想深入了解，可以参考以下文档。</p>
<p><a href="https://git-scm.com/docs/git-submodule">参数文档</a></p>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">使用文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireshark 简明教程</title>
    <url>/posts/65f8076a.html</url>
    <content><![CDATA[<p>Wireshark 作为一款免费的抓包工具深受工程师们的喜爱，下面就简单介绍一下如何使用。</p>
<span id="more"></span>

<h2 id="下载wireshark"><a href="#下载wireshark" class="headerlink" title="下载wireshark"></a>下载wireshark</h2><p><a href="https://www.wireshark.org/download.html">wireshark下载地址</a><br>选择Windows Installer (64-bit)，下载成功后一直点next就可以了。<br><img src="https://img-blog.csdnimg.cn/20210507224116599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>2.1 选择网卡<br>打开软件，界面如下所示，被红框标记起来的就是网卡列表，如果你使用的是无线网就可以选择WLAN。<br><img src="https://img-blog.csdnimg.cn/20210507224420963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.2 开始抓包<br>双击选中目标网卡就会进入到抓包主界面，如图：<br><img src="https://img-blog.csdnimg.cn/20210507224707882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>被红框选中的就是该网卡发送和接受的网络包了，后续会详细讲解如果通过wireshark抓包学习网络。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域</title>
    <url>/posts/a7eb5674.html</url>
    <content><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器，用来选取下一条需要执行的字节码指令</li>
<li>线程私有</li>
<li>唯一一个不会出现OOM的区域</li>
</ul>
<span id="more"></span>

<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul>
<li><p>线程私有</p>
</li>
<li><p>每个方法执行时都会创建对应的栈帧入栈，执行完毕后出栈，栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息</p>
</li>
<li><p>局部变量表</p>
<ul>
<li>用来存储基本数据类型、对象引用等信息</li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>线程私有</li>
<li>虚拟机使用到的本地（Native)方法服务（可以是C、C++等语言提供的服务）</li>
</ul>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><ul>
<li><p>线程共享</p>
</li>
<li><p>唯一目的就是存放对象实例，是内存中最大的一块</p>
</li>
<li><p>拥有常量池（jdk1.7 从永久代移动到堆）</p>
<ul>
<li><p>字符串常量池</p>
</li>
<li><p>运行时常量池</p>
<p>运行时常量池是方法区的一部分</p>
<ul>
<li>存放编译期生成的各种字面量与符号引用</li>
</ul>
</li>
<li><p>Class常量池</p>
<p>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致</p>
<ul>
<li>静态变量（jdk1.7 从永久代移动到堆 跟Class对象在一起）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法区-元空间"><a href="#方法区-元空间" class="headerlink" title="方法区/元空间"></a>方法区/元空间</h3><p>jdk7以前也被称为永久代，之后永久代的概念被舍弃,并提出元空间的概念。方法区就在元空间上（元空间和永久代都是方法区的具体实现，类似接口和实现类）</p>
<ul>
<li><p>线程共享</p>
</li>
<li><p>存储已被虚拟机加载的类型信息、即时编译器编译后的代码缓存数据等等（也叫元数据 包括类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的【存疑 】）</p>
</li>
<li><p>此区域的垃圾回收主要针对常量池和对类型的卸载</p>
<p>类型卸载：简单来说就是清理加载到内存中的Class 除非是故意设计不然这种情况发生的概率很低，因为Class是由ClassLoader加载进来的 而java虚拟机不会主动放弃ClassLoader 而Class又被ClassLoader引用，所以永远是“可达”的。</p>
</li>
</ul>
<h3 id="直接内存-堆外内存"><a href="#直接内存-堆外内存" class="headerlink" title="直接内存(堆外内存)"></a>直接内存(堆外内存)</h3><ul>
<li>直接使用物理内存不受到堆大小的限制，但受本地总内存的限制</li>
<li>优点：提高性能，避免在java堆和native堆来回复制数据</li>
<li>缺点：如果直接内存发生OOM排查难度较高</li>
</ul>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ul>
<li><p>1、类加载：先去常量池找类的符号引用并检查是否已加载</p>
</li>
<li><p>2、分配内存</p>
<ul>
<li><p>分配方法</p>
<ul>
<li><p>2.1 指针碰撞</p>
<ul>
<li>堆内存规整时使用，已使用和未使用的内存划分到两边，分配内存时指针向空闲空间移动</li>
</ul>
</li>
<li><p>2.2 空间列表</p>
<ul>
<li>堆内存不规整时使用，维护一个内存使用情况列表，分配内存时跟据表数据选取内存空间</li>
</ul>
</li>
</ul>
</li>
<li><p>解决并发安全问题</p>
<ul>
<li>同步处理，例如CAS</li>
<li>预先在堆中为每个线程分配一块内存，只有用完后分配新内存的时候再同步处理</li>
</ul>
</li>
</ul>
</li>
<li><p>3、执行构造函数<init>()</p>
</li>
</ul>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><ul>
<li><p>对象头</p>
<ul>
<li>1、存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</li>
<li>2、类型指针，虚拟机通过这个指针来确定对象是哪个类的实例</li>
<li>3、如果是数组还有一块区域记录数组长度，因为虚拟机无法通过元数据推断数组的大小</li>
</ul>
</li>
<li><p>实例数据</p>
<ul>
<li>对象真正存储的有效信息，即代码中定义的各种类型的字段内容</li>
</ul>
</li>
<li><p>对齐填充</p>
<ul>
<li>占位符的作用，因为对象的大小必须是8字节的整数倍，但实例数据可能不是 所以用它来补全</li>
</ul>
</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul>
<li><p>句柄访问</p>
<ul>
<li><p>Java堆中划分出一块内存做句柄池，局部变量表中存储句柄地址，句柄中存储对象实例数据与类型数据的内存地址</p>
<ul>
<li>优点：如果对象被移动指挥改变句柄中的实例数据指针</li>
</ul>
</li>
</ul>
</li>
<li><p>直接指针访问</p>
<ul>
<li><p>堆中对象的内存布局需要存储对应类型数据的地址，局部变量表中存储的是对象地址</p>
<ul>
<li>优点：速度快，因为节省了一次定位指针的时间开销</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型与线程</title>
    <url>/posts/badf9669.html</url>
    <content><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>内存模型一词可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；<br>在jdk5发布后Java内存模型才终于成熟、完善起来</p>
<span id="more"></span>

<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节（这里的变量特指实例字段、静态字段、构成数组对象的元素，不包括局部变量与方法参数，因为后者是线程私有的）</p>
<ul>
<li><p>主内存</p>
<p>Java模型规定了所有变量都存储在主内存中，线程间变量值的传递均需要通过主内存来完成</p>
<ul>
<li>对应Java堆总对象实例数据</li>
</ul>
</li>
<li><p>工作内存</p>
<p>每条线程都有自己的工作内存，线程私有，里面保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。</p>
<ul>
<li>对应虚拟机栈中的部分区域</li>
</ul>
</li>
</ul>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存</p>
<ul>
<li><p>8种操作</p>
<p>虚拟机保证每一种操作都是原子的</p>
<ul>
<li><p>lock锁定</p>
<p>作用于主内存的变量，它把一个变量标识为一条线程独占的状态</p>
</li>
<li><p>unlock 解锁</p>
<p>作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p>
</li>
<li><p>read 读取</p>
<p>作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中</p>
</li>
<li><p>load 载入</p>
<p>作用于工作内存的变量，它把read操作得到的变量值放入工作内存的变量副本中</p>
</li>
<li><p>use 使用</p>
<p>作用于工作内存的变量，它把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码执行时将会执行这个操作</p>
</li>
<li><p>assign 赋值</p>
<p>作用于工作内存的变量，它把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码执行时执行这个操作</p>
</li>
<li><p>store 存储</p>
<p>作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中</p>
</li>
<li><p>write 写入</p>
<p>作用于主内存的变量，它把store操作得到的变量值放入主内存的变量中</p>
</li>
</ul>
</li>
</ul>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>Java虚拟机提供的最轻量级的同步机制</p>
<ul>
<li><p>特性</p>
<ul>
<li><p>1、保证此变量堆所有线程的可见性</p>
<p>可见性：当一个线程修改了这个变量的值会立刻同步到主内存中，让其他线程立即得知</p>
</li>
<li><p>2、禁止指令重排序优化</p>
</li>
</ul>
</li>
</ul>
<h3 id="针对long和double型变量的特殊规则"><a href="#针对long和double型变量的特殊规则" class="headerlink" title="针对long和double型变量的特殊规则"></a>针对long和double型变量的特殊规则</h3><p>这两个数据类型是64位的，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的</p>
<ul>
<li><p>原子性</p>
<p>基本数据类型的访问、读写都是具备原子性的，如果需要更大范围的原子性保证，Java模型还提供了lock和unlock操作来满足需求</p>
</li>
<li><p>可见性</p>
<p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的；volatile、同步锁、final都可实现可见性</p>
</li>
<li><p>有序性</p>
<p>如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的，前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象</p>
</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>是Java内存模型中定义的两项操作之间的偏序关系，比如操作A先行发生于操作B，就是说在发生B操作之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等</p>
<h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul>
<li><p>内核实现（1：1 实现）</p>
<p>直接由操作系统内核支持的线程，这种线程由内核来完成线程切换、内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上</p>
<ul>
<li>优势：即使某个线程被阻塞了，也不会影响整个进行的工作</li>
<li>劣势：数量有限，每个进程都要消耗内核资源</li>
</ul>
</li>
<li><p>使用用户线程实现（1：N 实现）</p>
<p>一个线程如果不是内核线程就都认为是用户线程</p>
<ul>
<li>优势：快速且低消耗，不需要系统内核支援</li>
<li>劣势：没有系统内核支援，所有线程操作都需要用户程序自己处理</li>
</ul>
</li>
<li><p>用户线程加轻量级进程混合实现（N:M 实现）</p>
<p>内核线程与用户线程一起使用的实现方式</p>
</li>
<li><p>Java线程的实现</p>
<ul>
<li>基于内核实现（1：1实现）</li>
</ul>
</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>系统为线程分配处理器使用权的过程</p>
<ul>
<li><p>协同式线程调度</p>
<p>线程执行时间由线程本身控制，线程把自己的工作做完后要主动通知系统切换到另一个线程上去</p>
<ul>
<li>优势：实现简单，切换操作对线程自己式可知的所以没有线程同步问题</li>
<li>劣势：线程执行时间不可控，如果一个线程一直不通知系统进行线程切换会导致程序阻塞</li>
</ul>
</li>
<li><p>抢占式线程调度</p>
<ul>
<li><p>每个线程将由系统来分配执行时间，不由线程本身决定</p>
<ul>
<li>优势：不会因为一个线程导致系统阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>在任意一个时间点中，一个线程只能有且只有其中一种状态，并且可以通过特定的方法在不同状态之间转换</p>
<ul>
<li><p>新建（New）</p>
<p>创建后尚未启动的线程处于这种状态</p>
</li>
<li><p>运行（Runnable）</p>
<p>包括系统线程状态中的Running和Ready，有可能正在执行，也有可能正在等待系统为它分配执行时间</p>
</li>
<li><p>无限期等待（Waiting）</p>
<p>这个状态的线程不会被分配处理器执行时间，它们等待被其他线程显式唤醒</p>
<ul>
<li>1、没有设置Timeout参数的Object::wait()方法</li>
<li>2、没有设置Timeout参数的Thread::join()方法</li>
<li>3、LockSupport::park()方法</li>
</ul>
</li>
<li><p>限期等待（Timed Waiting）</p>
<p>无需其他线程显式唤醒，在一定时间后会被系统唤醒</p>
<ul>
<li>1、设置Timeout参数的Object::wait()方法</li>
<li>2、设置Timeout参数的Thread::join()方法</li>
<li>3、LockSupport::parkNanos()方法</li>
<li>4、LockSupport::parkUntil()方法</li>
</ul>
</li>
<li><p>阻塞</p>
<p>这个状态是在等待着获取到一个排它锁</p>
</li>
<li><p>结束</p>
<p>已经终止线程的线程状态，线程已经结束运行</p>
</li>
</ul>
<h2 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h2><h3 id="内核线程的局限性"><a href="#内核线程的局限性" class="headerlink" title="内核线程的局限性"></a>内核线程的局限性</h3><ul>
<li>劣势：调度成本高，需要频繁在用户态与核心态之间转换</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>应用自己模拟多线程的做法，属于用户线程</p>
<ul>
<li>优势：轻量</li>
<li>劣势：需要应用层面增加很多工作内容</li>
</ul>
<h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调度方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的</p>
<ul>
<li><p>Java语言中的线程安全</p>
<ul>
<li><p>不可变</p>
<p>不可变的对象一定是线程安全的</p>
</li>
<li><p>绝对线程安全</p>
<p>不管运行时环境如何，调用者都不需要任何额外的同步措施，因为这个条件很苛刻，导致Java api中标注自己是线程安全的类，大多数都不符合这个要求</p>
</li>
<li><p>相对线程安全</p>
<p>通常意义上所讲的线程安全，它保证对这个对象单次的操作是线程安全的，不需要进行额外的保障措施，但是对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段来保证调用的正确性</p>
</li>
<li><p>线程兼容</p>
<p>对象本身不是线程安全的，但是可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全的调用；我们通常说一个类不是线程安全的通常就是指这种情况</p>
</li>
<li><p>线程对立</p>
<p>不管是否使用同步措施在多线程环境中都是不安全的；这种情况应尽量避免</p>
</li>
</ul>
</li>
<li><p>线程安全的实现方法</p>
<ul>
<li><p>1、互斥同步</p>
<p>是一种最常见也是最主要的并发正确性保障手段，指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一条线程使用，最基本的互斥同步手段就是同步锁</p>
<ul>
<li><p>同步锁</p>
<p>jdk6以上版本的jdk中 性能已经不是选择这两个锁的决定性因素</p>
<ul>
<li><p>synchronized</p>
<p>更简单</p>
</li>
<li><p>lock</p>
<p>更灵活</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、非阻塞同步</p>
<p>基于冲突检测的乐观并发策略，如果有共享数据被争用就进行补偿措施，最常用的补偿措施就是不断重试，直到出现没有竞争的共享数据为止。</p>
<ul>
<li><p>CAS</p>
<ul>
<li>优势：性能好</li>
<li>劣势：不能处理ABA问题</li>
</ul>
</li>
</ul>
</li>
<li><p>3、无同步方案</p>
<ul>
<li><p>可重入代码</p>
<p>又称纯代码，指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后原来的程序不会出现任何错误，也不会对结果有所影响</p>
<ul>
<li>1、不依赖全局变量</li>
<li>2、不依赖存储在堆上的数据和公用的系统资源</li>
<li>3、用到的状态量都由参数中传入，不调用非可重入的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发程序设计</title>
    <url>/posts/dd8d8414.html</url>
    <content><![CDATA[<p>高并发是 java 开发必备知识，本篇文章整理出在高并发程序设计中常用的工具。</p>
<span id="more"></span>

<h2 id="java并发包"><a href="#java并发包" class="headerlink" title="java并发包"></a>java并发包</h2><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><ul>
<li><p>重入锁</p>
<p>重入锁使用java.util.concurrent.locks.ReentrantLock类来实现。<br>锁实现包含的三要素：1、原子装填，使用了CAS操作。 2、等待列队，所有没有请求到锁的线程会进入等待列队进行等待。  3、阻塞原语 park()和unpark() 用来挂起和恢复线程。</p>
<ul>
<li><p>特性</p>
<ul>
<li><p>中断响应</p>
<p>可以避免死锁，程序在等待锁的时候可以根据需要取消对锁的请求。<br>学习链接：<br><a href="https://blog.csdn.net/yyd19921214/article/details/49737061?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">https://blog.csdn.net/yyd19921214/article/details/49737061?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p>
<ul>
<li><p>什么是线程中断</p>
<p>学习链接：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554</a></p>
</li>
<li><p>如何使用此功能</p>
<p>使用lockInterruptible()方法可以获得拥有此功能的锁</p>
</li>
</ul>
</li>
<li><p>公平锁</p>
<p>公平锁会按照时间的先后顺序分配锁，但是性能低下，所以大多数情况下锁的申请都是非公平的。</p>
</li>
<li><p>锁申请等待限时</p>
<p>可以避免死锁，因为可以设置等待时间。可以通过tryLock()方法使用此功能。</p>
</li>
</ul>
</li>
<li><p>搭档 Condition</p>
<p>通过lock接口的 newCondition()方法可以生成一个与当前重入锁绑定的Condition实例，利用这个实例可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知继续执行。</p>
</li>
</ul>
</li>
<li><p>信号量 Semaphore</p>
<p>Semaphore(信号量)是java.util.concurrent下的一个工具类.用来控制可同时访问特定资源的线程数.内部是通过维护父类(AQS)的 int state值实现。<br>学习链接：<a href="https://zhuanlan.zhihu.com/p/27314456">https://zhuanlan.zhihu.com/p/27314456</a></p>
</li>
<li><p>ReadWriteLock 读写锁</p>
<p>可以有效帮助减少锁竞争，提升系统性能。主要应用于读操作的次数远远大于写操作的次数。<br>学习链接：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581002092578">https://www.liaoxuefeng.com/wiki/1252599548343744/1306581002092578</a></p>
</li>
<li><p>倒计数器 CountDownLatch</p>
<p>使用的多线程控制工具类，通常用来控制线程等待，它可以让某一个线程等待直到倒计数器结束再开始执行，它是一次性的，打开之后就不能关上了。<br>应用场景：在一个行为执行前需要执行很多前置步骤。<br>学习链接：<a href="https://www.jianshu.com/p/962bc7225ce8">https://www.jianshu.com/p/962bc7225ce8</a></p>
</li>
<li><p>循环栅栏 CyclicBarrier</p>
<p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。<br>叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用；跟 CountDownLatch功能类似，但是更灵活、更强大、更复杂。<br>学习链接：<a href="https://www.jianshu.com/p/4ef4bbf01811">https://www.jianshu.com/p/4ef4bbf01811</a></p>
</li>
<li><p>线程阻塞工具类 LockSupport</p>
<p>LockSupport 是一个线程阻塞工具，可以让线程在任意位置阻塞；<br>应用实例：一个节点线程获取不到锁时，会阻塞自己，调用的就是LockSupport的park()方法，返回只有两种方式，前一个节点线程释放锁时unpark()了当前节点，或者当前节点线程被中断返回。</p>
</li>
<li><p>限流工具 Guava的RateLimiter</p>
<p>应用或者组件都有访问上限，如果突破这个上限不仅会影响其性能，更可能会导致其崩溃，因此，对请求进行限流是必要的。<br>学习链接：<a href="https://juejin.im/post/6844903783432978439">https://juejin.im/post/6844903783432978439</a></p>
<ul>
<li><p>漏桶算法</p>
<p>利用缓存，当有请求进入系统时无论请求速率如何，都先在缓存区内保存，然后以固定的流苏流出缓存区进行处理。</p>
</li>
<li><p>令牌桶算法</p>
<p>桶中存放的不是请求而是令牌，处理程序只有拿到令牌后才能对请求进行处理，如果没有令牌可能被丢弃也可能等待可用令牌</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程复用：线程池"><a href="#线程复用：线程池" class="headerlink" title="线程复用：线程池"></a>线程复用：线程池</h3><ul>
<li><p>Executor框架</p>
<ul>
<li><p>Executors类</p>
<ul>
<li><p>newFixedThreadPool()</p>
<p>返回一个固定线程数量的线程池，待执行任务保存在队列中</p>
</li>
<li><p>newSingleThreadExecutor()</p>
<p>返回只有一个线程的线程池，待执行任务保存在队列中</p>
</li>
<li><p>newCachedThreadPool()</p>
<p>返回一个可根据实际情况调整线程数量的线程池</p>
</li>
<li><p>newScheduledThreadPool()</p>
<p>返回ScheduleExecutorService对象，可以执行线程的数量</p>
</li>
<li><p>newSingleThreadScheduledExector()</p>
<p>返回ScheduledExectorService对象，只有一个线程，可以设置执行任务相关的时间参数</p>
</li>
<li><p>。。。。</p>
</li>
</ul>
</li>
<li><p>自定义线程创建 ThreadFactory</p>
</li>
<li><p>扩展线程池 ThreadPoolExector</p>
<p>提供了 beforeExecute()、afterExecute()和terminated() 三个接口用来对线程池进行控制</p>
</li>
<li><p>输出异常堆栈</p>
<ul>
<li><p>使用execute()方法</p>
<p>submit()会忽略系统抛出的异常</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分而治之 Fork/Join框架</p>
<p>学习链接：<a href="https://www.liaoxuefeng.com/article/1146802219354112">https://www.liaoxuefeng.com/article/1146802219354112</a></p>
</li>
<li><p>Guava对线程池的扩展</p>
<ul>
<li><p>DirectExecutor线程池</p>
<p>它并没有真的创建或者使用额外线程，它总是将任务在当前线程中直接执行。这个设计主要是为了完成业务的抽象工作，可以使用同一的编码风格处理同步和异步调用，进而简化设计。</p>
</li>
<li><p>Daemon线程池</p>
<p>将普通线程池转为Daemon线程池，可以随着系统（也可以叫主线程）执行完成后一起销毁</p>
</li>
<li><p>Future模型的扩展</p>
<p>Future模式核心思想是异步调用，线程会在等待结果返回的过程中执行其他业务，从而充分利用这段时间</p>
<ul>
<li><p>ListeningExecutorService</p>
<p>调用 MoreExecutors.listeningDecorator 方法将一个普通线程池包装为一个包含通知同能的Future线程池</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="java并发容器"><a href="#java并发容器" class="headerlink" title="java并发容器"></a>java并发容器</h2><h3 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h3><ul>
<li><p>ConcurrentHashMap</p>
<p>高效的并发,线程安全的HashMap</p>
</li>
<li><p>CopyOnWriteArrayList</p>
<p>线程安全的ArrayList 适合读多写少的场合，性能远好于Vector。<br>读取不加锁，写入也不会阻塞读取操作，只有写入和写入会加锁，因为在写入操作时会进行一次自我复制</p>
</li>
<li><p>ConcurrentLinkedQueue</p>
<p>高效并发队列，链表实现可以看作是线程安全的LinkedList，是高并发环境中性能最好的队列</p>
</li>
<li><p>BlokingQueue</p>
<p>阻塞队列，适合做数据共享通道。非常适合作为“生产和–消费者”模式的数据同步工具，在队列为空的时候会让读取阻塞，而当队列满了后会让存储操作阻塞</p>
</li>
<li><p>ConcurrentSkipListMap</p>
<p>跳表实现，一种可以用来快速查找的数据结构。</p>
<ul>
<li><p>高性能</p>
<p>类似平衡树，区别是对平衡树的插入和删除往往很可能导致平衡树进行一次全局调整，而跳表只需要对整个数据结构的局部进行操作即可。这样就可以控制锁的粒度。</p>
</li>
<li><p>随机算法</p>
<p>跳表本质是同时维护了多个链表，并且链表是分层的，底层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层链表的子集，一个元素插入哪些层是随机的。<br>查找操作时跳跃式的，跳表内所有链表的元素都是排序的，查找时会从顶层开始，一旦发现被查找的元素大于当前链表中的取值就会转入下一层继续查找。</p>
<ul>
<li>疑问：为什么插入是随机的 但是查找可以按照顺序查找呢？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="JMH进行性能测试"><a href="#JMH进行性能测试" class="headerlink" title="JMH进行性能测试"></a>JMH进行性能测试</h2><p>学习链接：<a href="https://www.xncoding.com/2018/01/07/java/jmh.html">https://www.xncoding.com/2018/01/07/java/jmh.html</a></p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="提高性能的建议"><a href="#提高性能的建议" class="headerlink" title="提高性能的建议"></a>提高性能的建议</h3><ul>
<li><p>1、减少锁的持有时间</p>
<p>尽量不要在同步代码块中做耗时的操作，并且只在必要时进行同步</p>
</li>
<li><p>2、减小锁的粒度</p>
<p>需要同步的代码块要尽量小</p>
</li>
<li><p>3、用读写分离锁替换独占锁</p>
</li>
<li><p>4、锁分离</p>
<p>是读写锁的上层思想，可以将功能进行拆分，并根据每个功能的实际需求进行定制化的操作</p>
</li>
<li><p>5、锁粗化</p>
<p>对同一个锁不断进行请求和释放的操作时便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数</p>
</li>
</ul>
<h3 id="java虚拟机对锁的优化"><a href="#java虚拟机对锁的优化" class="headerlink" title="java虚拟机对锁的优化"></a>java虚拟机对锁的优化</h3><ul>
<li><p>锁偏向</p>
<p>是一种针对加锁操作的优化。<br>核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时无须再做任何同步操作。<br>但是在锁竞争比较激烈的场合其效果不佳，因为可能每次请求锁的都不是同一个线程，所以不建议在竞争激烈的环境下启用</p>
</li>
<li><p>轻量级锁</p>
<p>它只是简单地将对象头部作为指针指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果加锁失败就会转为重量级锁。<br>学习链接：<a href="https://www.zhihu.com/question/53826114">https://www.zhihu.com/question/53826114</a></p>
</li>
<li><p>自旋锁</p>
<p>虚拟机会让当前线程做几个空循环，在经过若干次循环后如果可以得到锁，那么就会顺利进入临界区，如果不能获得锁会在操作系统层面挂起</p>
</li>
<li><p>锁消除</p>
<p>虚拟机在编译过程中会去除不可能存在共享资源竞争的锁，通过这种措施可以节省毫无意义的请求锁时间。<br>之所以有这一操作，一方面是防止用户的错误使用。 另一方面用户在使用jdk提供的api时，api内部实现可能使用了同步锁</p>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>本质是通过增加资源来保证所有对象的线程安全，会为每一个线程保存一份资源的副本，这样就不会产生竞争，但是用完要及时清理资源，不然容易发生内存泄漏。<br>学习链接：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666">https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666</a></p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>乐观锁的思想，它会假设对资源的访问是没有冲突的，无锁的策略使用CAS的技术来鉴别线程冲突，一旦检测到冲突产生就重试当前操作直到没有冲突为止。</p>
<ul>
<li><p>CAS</p>
<p>乐观锁，并没有真的是使用同步锁，当多个线程同时使用CAS操作一个变量时只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，也允许放弃操作。</p>
</li>
<li><p>安全整数 AtomicInteger</p>
<p>线程安全的整数，使用CAS操作</p>
</li>
<li><p>无锁的对象引用 AtomicReference</p>
<p>保证修改对象引用时的线程安全性</p>
<ul>
<li>缺点：无法解决ABA问题</li>
</ul>
</li>
<li><p>带时间戳的对象引用 AtomicStampedReference</p>
<ul>
<li>优势：通过时间戳解决ABA问题</li>
</ul>
</li>
<li><p>无锁数组 AtomicIntegerArray</p>
</li>
<li><p>让普通变量也享受原子操作 AtomicIntegerFieldUpdater</p>
<p>可以对int、long和普通对象引用进行CAS修改；<br>注意事项：<br> 变量必须public 因为底层使用了反射获取变量的值<br>必须被volatile修饰<br>不支持static修饰的变量，因为会通过对象实例中的偏移量直接进行赋值</p>
</li>
<li><p>数据交换通道 SynchronousQueue</p>
<p>学习链接：<a href="https://blog.csdn.net/zmx729618/article/details/52980158">https://blog.csdn.net/zmx729618/article/details/52980158</a></p>
</li>
</ul>
<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="Disruptor-框架"><a href="#Disruptor-框架" class="headerlink" title="Disruptor 框架"></a>Disruptor 框架</h3><p>高效无锁内存队列 可以用来实现高性能的 生产者–消费者模式</p>
<h3 id="Akka框架"><a href="#Akka框架" class="headerlink" title="Akka框架"></a>Akka框架</h3><p>帮助构建高并发程序</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mybatis源码解读】jdbc包</title>
    <url>/posts/693eec27.html</url>
    <content><![CDATA[<h2 id="1-jdbc包的作用"><a href="#1-jdbc包的作用" class="headerlink" title="1. jdbc包的作用"></a>1. jdbc包的作用</h2><p>jdbc包作为Mybatis框架的核心包之一可以理解为是<strong>操作Sql的工具包</strong>，因为通过阅读代码观察到这个jdbc包里面的类并没有被Mybatis框架本身引用，而其本身的作用又是对sql的操作，所以当作工具包来理解是没有什么问题的。</p>
<span id="more"></span>

<h2 id="2-设计思想"><a href="#2-设计思想" class="headerlink" title="2. 设计思想"></a>2. 设计思想</h2><p>利用面向对象的<strong>继承</strong>特性增加功能的<strong>拓展性</strong>。</p>
<h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h2><p>jdbc包里面的类其实很少，去掉过期的和一些辅助类主要的类有三个：<strong>AbstractSQL</strong>、<strong>ScriptRunner</strong>、<strong>SqlRunner</strong>，这里着重介绍<strong>AbstractSQL</strong>类，因为相对于<strong>AbstractSQL</strong>类另外的两个类功能很简单。</p>
<p><strong>AbstractSQL</strong>的类图:</p>
<p>可以看出SQL类继承了<strong>AbstractSQL</strong>类，而SafeAppendable 和 SQLStatement 是<strong>AbstractSQL</strong>的内部类，下面逐一介绍。</p>
<p><img src="https://s2.loli.net/2021/12/05/pJT69AcKPMHEqxf.png" alt="image-20201206170511920"></p>
<h3 id="SQL类"><a href="#SQL类" class="headerlink" title="SQL类"></a>SQL类</h3><h4 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1 简介"></a>3.1.1 简介</h4><p>SQL类的实现很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQL</span> <span class="keyword">extends</span> <span class="title">AbstractSQL</span>&lt;<span class="title">SQL</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SQL <span class="title">getSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说所有的逻辑实现都写在了它的父类中，那为什么还要SQL类呢？答案就是为了<strong>增加功能的拓展性</strong>，比如你想在生成sql的时候满足一些定制化的需求可以重新创建一个子类继承并拓展它。</p>
<h4 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2 使用"></a>3.1.2 使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserProvider.class, method = &quot;queryUsersBySchoolName&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUsersBySchoolName</span><span class="params">(String schoolName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUsersBySchoolName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .FROM(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .WHERE(<span class="string">&quot;schoolName = #&#123;schoolName&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这种方式是直接在每个接口上引入sql，如果项目比较庞大是很难有效管理sql的 ，所以这种使用方式很不常见。</p>
<h3 id="SafeAppendable"><a href="#SafeAppendable" class="headerlink" title="SafeAppendable"></a>SafeAppendable</h3><h4 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1 简介"></a>3.2.1 简介</h4><p>看名字就可以了解到这个类里面封装了<strong>拼接</strong>字符的行为，使用了<strong>组合模式</strong>持有了Appendable接口实例的引用，并调用其append方法实现拼接，拼接完成后调用Appendable实例的toString方法获取拼接结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeAppendable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Appendable a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeAppendable</span><span class="params">(Appendable a)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SafeAppendable <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty &amp;&amp; s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          empty = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a.append(s);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SQLStatement"><a href="#SQLStatement" class="headerlink" title="SQLStatement"></a>SQLStatement</h3><h4 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1 简介"></a>3.3.1 简介</h4><p>从下图为此类封装的方法，可以看出此类是拼接sql的主力军。</p>
<p><img src="https://s2.loli.net/2021/12/05/PtIn4eRMAJwXsVx.png" alt="image-20201206180137582"></p>
<p>下图这些为此类的属性，从名字可以看出是根据sql关键字进行分类的，存储着相应的值，用来拼接sql时使用。</p>
<p><img src="https://s2.loli.net/2021/12/05/74HvADUTKCeFadm.png" alt="image-20201206180617860"></p>
<p>以拼接select为例分析源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//只接收一个参数就是拼接器，用来拼接字符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">selectSQL</span><span class="params">(SafeAppendable builder)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//判断是否需要去重，如果需要就增加 DISTINCT关键字，而select为上图的属性，是一个集合里面存储着相应的值，下面几个参数类似不做赘述，下面会对sqlClause方法做详细解释。</span></span><br><span class="line">     <span class="keyword">if</span> (distinct) &#123;</span><br><span class="line">       sqlClause(builder, <span class="string">&quot;SELECT DISTINCT&quot;</span>, select, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       sqlClause(builder, <span class="string">&quot;SELECT&quot;</span>, select, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     sqlClause(builder, <span class="string">&quot;FROM&quot;</span>, tables, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">     <span class="comment">//join语句比较特殊，所以单独创建函数，但是本质也是复用sqlClause函数</span></span><br><span class="line">     joins(builder);</span><br><span class="line">     sqlClause(builder, <span class="string">&quot;WHERE&quot;</span>, where, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot; AND &quot;</span>);</span><br><span class="line">     sqlClause(builder, <span class="string">&quot;GROUP BY&quot;</span>, groupBy, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">     sqlClause(builder, <span class="string">&quot;HAVING&quot;</span>, having, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot; AND &quot;</span>);</span><br><span class="line">     sqlClause(builder, <span class="string">&quot;ORDER BY&quot;</span>, orderBy, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">     <span class="comment">//利用LIMIT、OFFSET关键字做分页处理</span></span><br><span class="line">     limitingRowsStrategy.appendClause(builder, offset, limit);</span><br><span class="line">     <span class="keyword">return</span> builder.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面是sqlClause 函数的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：拼接器；参数二：关键字例如SELECT等等;参数三：sql所需值的集合；参数四和五：参数开始和结束字符 例如where语句需要括号括起来；参数六：参数连接字符例如 AND等等</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlClause</span><span class="params">(SafeAppendable builder, String keyword, List&lt;String&gt; parts, String open, String close,String conjunction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!parts.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!builder.isEmpty()) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(keyword);</span><br><span class="line">    builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    builder.append(open);</span><br><span class="line">    String last = <span class="string">&quot;________&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = parts.size(); i &lt; n; i++) &#123;</span><br><span class="line">      String part = parts.get(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !part.equals(AND) &amp;&amp; !part.equals(OR) &amp;&amp; !last.equals(AND) &amp;&amp; !last.equals(OR)) &#123;</span><br><span class="line">        builder.append(conjunction);</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(part);</span><br><span class="line">      last = part;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(close);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractSQL"><a href="#AbstractSQL" class="headerlink" title="AbstractSQL"></a>AbstractSQL</h3><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1 简介"></a>3.4.1 简介</h4><p>如果理解了前面三个类的作用那理解此类的作用也就水到渠成了，下面看下此类封装的方法，可以看到所有方法都是以sql语句的关键词命名的</p>
<p><img src="https://s2.loli.net/2021/12/05/nZctYG87sJqrvmK.png" alt="image-20201207221124727"></p>
<h4 id="3-4-2-详解"><a href="#3-4-2-详解" class="headerlink" title="3.4.2 详解"></a>3.4.2 详解</h4><p>以SELECT方法为例，当使用如下方法时发生了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SQL()</span><br><span class="line">              .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">              .FROM(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">              .WHERE(<span class="string">&quot;schoolName = #&#123;schoolName&#125;&quot;</span>)</span><br><span class="line">              .toString();</span><br></pre></td></tr></table></figure>

<p>当调用AbstractSQL里面封装的方法时其实都将传进来的值存储在了SQLStatement相应关键字的属性中，当最后调用toString方法时就会触发sql的拼接工作，所以可以理解为AbstractSQL是给SQLStatement类做了一层<strong>装饰器</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">SELECT</span><span class="params">(String columns)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//sql() 方法会返回SQLStatement类的一个实例</span></span><br><span class="line">    <span class="comment">//设置sql类别</span></span><br><span class="line">  sql().statementType = SQLStatement.StatementType.SELECT;</span><br><span class="line">    <span class="comment">//将传入的值存储到SQLStatement类的select属性中</span></span><br><span class="line">  sql().select.add(columns);</span><br><span class="line">    <span class="comment">//返回对象本身</span></span><br><span class="line">  <span class="keyword">return</span> getSelf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他关键字方法的调用都是类似的，这里不再赘述，下面介绍一下<strong>如何触发拼接sql的操作</strong>：</p>
<p>当调用toString方法时就会触发sql拼接操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个字符拼接器</span></span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//调用SQLStatement类的sql方法，此方法会利用StringBuilder拼接sql</span></span><br><span class="line">  sql().sql(sb);</span><br><span class="line">    <span class="comment">//转化为字符串</span></span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法会根据sql的类型调用相应的拼接方法，而SELECT语句如何拼接的前文已经讲解过，大家可以按照此方法查看一下其他类型sql的拼接过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sql</span><span class="params">(Appendable a)</span> </span>&#123;</span><br><span class="line">  SafeAppendable builder = <span class="keyword">new</span> SafeAppendable(a);</span><br><span class="line">  <span class="keyword">if</span> (statementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String answer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (statementType) &#123;</span><br><span class="line">    <span class="keyword">case</span> DELETE:</span><br><span class="line">      answer = deleteSQL(builder);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> INSERT:</span><br><span class="line">      answer = insertSQL(builder);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      answer = selectSQL(builder);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UPDATE:</span><br><span class="line">      answer = updateSQL(builder);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      answer = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br></pre></td></tr></table></figure>

<p>这里有个细节，为什么AbstractSQL类中的方法都是大写的呢？ 我查阅了相关资料发现这是为了照顾大家写sql时的习惯。</p>
<p>通过以上知识的学习我们就应该知道 Mybatis 是如何操作 sql 的了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>【通过抓包学网络】TCP三次握手与四次挥手﻿</title>
    <url>/posts/b65feaa2.html</url>
    <content><![CDATA[<p>本文章是通过wireshark来抓包的，如果你对这个工具不熟悉可以看这篇文章<a href="https://blog.csdn.net/qq_43005544/article/details/116504407">wireshark 简易教程</a></p>
<span id="more"></span>

<p><strong>正文开始</strong></p>
<h1 id="1-首先抓个包"><a href="#1-首先抓个包" class="headerlink" title="1.首先抓个包"></a>1.首先抓个包</h1><p>通过上一篇文章大家应该都能打开对应网卡的抓包页面了哈；我们利用DNS服务可以将域名解析成IP的功能来演示如何抓到我们想要的包。</p>
<h2 id="1-1-开始抓包"><a href="#1-1-开始抓包" class="headerlink" title="1.1 开始抓包"></a>1.1 开始抓包</h2><p>如果进入抓包页面没有自动开始抓包，就点击左上角的开始抓包按钮，如图：<br><img src="https://img-blog.csdnimg.cn/20210507235225375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-2-打开命令行界面"><a href="#1-2-打开命令行界面" class="headerlink" title="1.2 打开命令行界面"></a>1.2 打开命令行界面</h2><p>博主用的win10操作系统，所以打开的就是CMD了，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;nslookup</span><br><span class="line">&gt;<span class="built_in">set</span> vc</span><br><span class="line">&gt;www.baidu.com</span><br></pre></td></tr></table></figure>
<p>命令执行情况如图：<br><img src="https://img-blog.csdnimg.cn/20210507233243944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-3-停止抓包"><a href="#1-3-停止抓包" class="headerlink" title="1.3 停止抓包"></a>1.3 停止抓包</h2><p>点击红框标记的按钮：<br><img src="https://img-blog.csdnimg.cn/20210507235328579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-4-筛选"><a href="#1-4-筛选" class="headerlink" title="1.4 筛选"></a>1.4 筛选</h2><p>这个时候可以看到界面上抓到很多包，但是有很多是其他应用进行的网络请求，并不是我们想要的，所以要进行筛选。<br>在筛选框我们用Ip进行筛选，表达式为<strong>ip.addr == 116.199.0.200</strong>，如图<br><img src="https://img-blog.csdnimg.cn/20210507235517845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>116.199.0.200是我本机DNS的ip，你可以通过刚在输入的nslookup命令得到，如图<br><img src="https://img-blog.csdnimg.cn/20210507235651897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是通过筛选后发现还是有很多包不是我们想要的，我们通过info列来找到我们请求DNS的包，如图：<br>找到DNS协议info这列有我们刚才输入需要解析的域名这两行，这两行就是DNS解析域名的过程，我们从这两行的Info就可以很清晰的看出DNS解析域名的过程，首先192.168.1.107询问DNS <a href="http://www.baidu.com的ip是多少,然后dns在下一行进行回复./">www.baidu.com的IP是多少，然后DNS在下一行进行回复。</a><br><img src="https://img-blog.csdnimg.cn/20210509113130576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-5-找到三次握手的包"><a href="#1-5-找到三次握手的包" class="headerlink" title="1.5 找到三次握手的包"></a>1.5 找到三次握手的包</h2><p>在1.4小节中我们找到的926和927号包的上面就是三次握手的包，分别是921，922，923这三个包，如图：<br><img src="https://img-blog.csdnimg.cn/20210509161642786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>你可能想问是怎么看出来的，好问题，主要是看Seq和Ack的值，三次握手的时候Seq的相对值是为0的（注意是相对值）。找到了三次握手的网络包，我们就来分析一下三次握手吧。</p>
<h1 id="2-分析三次握手"><a href="#2-分析三次握手" class="headerlink" title="2. 分析三次握手"></a>2. 分析三次握手</h1><h2 id="2-1-TCP-参数介绍"><a href="#2-1-TCP-参数介绍" class="headerlink" title="2.1 TCP 参数介绍"></a>2.1 TCP 参数介绍</h2><p>要学习TCP首先要学习它的参数。</p>
<p><strong>Seq</strong>：标识改数据段的序号。因为TCP的传输是有序的，接收者可以通过Seq对包进行排序。</p>
<p><strong>Len</strong>：表示Seq对应数据的长度。</p>
<p><strong>Ack</strong>：确认号，向数据提供者表明收到了哪些包（实际收到包的Seq序号需要 Ack - 1，因为Seq是从0开始的，例如Ack = 2说明已经收到 第0段和第1段需要包，下一个需要接收的序号包Seq 需要为 2）。</p>
<p><strong>SYN</strong>：表示携带这个参数的数据包正在发起连接请求。</p>
<p><strong>FIN</strong>：表示携带这个参数的包正在请求停止连接。</p>
<h2 id="2-2-三次握手过程"><a href="#2-2-三次握手过程" class="headerlink" title="2.2 三次握手过程"></a>2.2 三次握手过程</h2><p>用来分析的数据包如图：<br><img src="https://img-blog.csdnimg.cn/2021050917000075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>第一次握手</strong> 192.168.1.107 向 116.119.0.200 发送携带 SYN; Seq = 0;len = 0的请求。SYN表示这是在请求连接，Seq表示目前发送的是第0段数据包，len表示数据包的长度为0。</p>
<p><strong>第二次握手</strong> 116.119.0.200 向192.168.1.107发送携带SYN;Seq = 0;Len = 0; Ack = 1的请求。因为TCP是双向连接，所以双方都要维护各自的参数，除了Ack其他参数在第一次握手的时候讲过了，Ack表示已经接收到Seq = 0 的数据包了，下一次请从Seq = 1 的数据包发送。</p>
<p><strong>第三次握手</strong>：192.168.1.107 向 116.119.0.200 发送携带Ack = 1; Seq = 1; len = 0;的请求，表示已经收到Seq = 0 的数据包了，下一次请从Seq = 1 的数据包发送。<br>这时连接已经成功建立。</p>
<p>这样就通过三次握手建立了一个连接，<strong>至于面试常问的为什么不是两次或者四次相信你已经知道答案了</strong>，因为<strong>两次不可靠</strong>，可能在第二次握手的时候超时了，对方并没有收到请求，而发送方并不知道，以为已经成功建立了连接，所以会向对方发送数据，但是对方因为其他原因没有接收到第二次握手，所以不会接受数据发送方发送的数据。<strong>至于四次没必要</strong>，因为所有想做的事情已经做完了。</p>
<h1 id="3-分析四次挥手"><a href="#3-分析四次挥手" class="headerlink" title="3. 分析四次挥手"></a>3. 分析四次挥手</h1><h2 id="3-1-找到四次挥手的数据包"><a href="#3-1-找到四次挥手的数据包" class="headerlink" title="3.1 找到四次挥手的数据包"></a>3.1 找到四次挥手的数据包</h2><p>四次挥手的数据包就是928至931，你又想问这是怎么看出来的？好问题，讲三次握手的时候介绍过 <strong>FIN</strong>参数就代表着请求断开连接，那我们就找离DNS解析域名数据包最近的携带FIN参数的数据包。<br><img src="https://img-blog.csdnimg.cn/20210509174830567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDA1NTQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-2-分析四次挥手"><a href="#3-2-分析四次挥手" class="headerlink" title="3.2 分析四次挥手"></a>3.2 分析四次挥手</h2><p><strong>第一次挥手</strong>：192.168.1.107 向 116.119.0.200 发送携带FIN; Seq = 34; Ack = 93; 的数据包，FIN表示请求断开连接，Seq = 34表示这个数据包是第34段，Ack = 93表示已经收到93段之前的数据包了，下一次请求第93段数据包开始发送。</p>
<p><strong>第二次挥手</strong>： 116.119.0.200 向192.168.1.107发送携带Seq = 93; Ack = 35;的数据包，表示请求已经收到 Seq和Ack参数就不解释了。</p>
<p><strong>第三次挥手</strong>：116.119.0.200 向192.168.1.107发送携带FIN; Seq = 93; Ack = 35; 的数据包，表示请求断开连接。</p>
<p><strong>第四次挥手</strong>：192.168.1.107 向 116.119.0.200 发送携带Seq = 35; Ack = 94;的数据包，表示已经接收到请求。</p>
<p>通过四次挥手完成了连接的断开，<strong>面试的时候常问为什么不能是三次挥手</strong>，这里已经很明确了，因为116.119.0.200这台服务器需要连续发送两个数据包，那为什么是两个呢？因为可能还有一些网络数据没有处理完，不能马上断开连接，只能先回应请求收到了，等处理完数据后再发送断开连接请求。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Wireshark</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性算法-Paxos</title>
    <url>/posts/8bee0b02.html</url>
    <content><![CDATA[<h2 id="Paxos-是如何保证一致性的"><a href="#Paxos-是如何保证一致性的" class="headerlink" title="Paxos 是如何保证一致性的"></a>Paxos 是如何保证一致性的</h2><p><strong>答案是通过持久化变化的日志流来保证一致性的。</strong>你会问这是为什么。这需要你带着这个问题来看下面的示例：</p>
<p>如图：我们现在部署了三个节点的集群，分别是 Node 1,Node 2,Node 3。这三个节点中的任何一个节点都可以写入数据，同时任何一个节点被写入数据后都会将数据同步给其他两个节点，现在有三个客户端分别在三个节点写入 a, b, c。问，当查询的时候数据按照哪种顺序排列是正确的？</p>
<span id="more"></span>

<p><img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220209193951005.png" alt="image-20220209193951005"></p>
<p>答案如下图：<strong>三个节点返回的数据顺序只要是一样的就是正确的，即总共有 6 种正确答案。</strong></p>
<p><img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220209195241655.png" alt="image-20220209195241655"></p>
<p>每个节点写入数据的时候都会将这个数据写入到日志中，后续写入的数据都以 append 的形式追加到日志中，<strong>所以如果我们保证所有节点的日志是一致的那么就可以达到在并发情况下的一致性需求，同时，如果一个节点宕机了，等它重启后再加载一遍日志后就能将数据恢复也解决了数据丢失的问题。</strong></p>
<h3 id="如何保证节点的日志是一致的"><a href="#如何保证节点的日志是一致的" class="headerlink" title="如何保证节点的日志是一致的"></a>如何保证节点的日志是一致的</h3><p>首先，我们要明确一点，每个节点的日志在写入的时候都会明确现在写入的是第几个。这样才能保证顺序是一致的。就用上面的例子来说，每个节点的日志都有三个位置，如果 Node 1 的1号位置写入的是 a ，那么其他两个节点就不能写到1号位置了，只能选择 2 号位置或者 3 号位置，如果 2 号位置被占了就再往后推。这样每个节点对于几号位置写入什么数据就都达成了共识，那么最终结果就是每个节点的日志顺序都是一样的。</p>
<p>这里的关键思想是：虽然每个Node接收到的请求顺序不同，但它们对于日志中1号位置、2号位置、3号位置的认知是一样的，大家一起保证1号位置、2号位置、3号位置存储的数据一样！在例子中可以看到，每个Node在存储日志之前先要问一下其他Node，之后再决定把这条日志写到哪个位置。这里有两个阶段：先问，再做决策，也就是Paxos2PC的原型！</p>
<p><strong>但是在并发的情况下这个看似简单的问题也会变得特别复杂。</strong>例如，Node1询问后发现1号位置没有被占，因此它打算把 a 传播给Node2和Node3；同一时刻，Node2询问后发现1号位置也没有被占，因此它打算把 b 传播给Node1和Node3；同样，Node3也打算把 c 传播给Node1和Node2。<strong>这样不就冲突了吗？</strong></p>
<p><strong>为了解决这个问题 Paxos 规定了如下流程：</strong> </p>
<p>第一，发现1号位置的值被大多数确定了，比如是 c（node3占领了1号位置，Node2跟从了Node3），则Node1就接受这个事实：1号位置不能用了，也得把自己的1号位置赋值成 c 。然后看2号位置能否把 a 存进去。同样地，如果2号也被占领了，就只能把它们的值拿过来填在自己的2号位置。只能再看3号位置是否可行。</p>
<p>第二，当发现1号位置没有被占，就锁定这个位置，不允许其他Node再占这个位置！除非它的权利更大。</p>
<p>第三，如果发现1号位置为空，在提交的时候发现1号位置被其他Node占了，就会提交失败，重试，尝试第二个位置，第三个位置……所以，为了让1号位置日志一样，可能要重试好多次，每个节点都会不断重试2PC。这样不断重试2PC，直到最终各方达成一致的过程，就是Paxos协议执行的过程，也就是一个Paxos instance，最终确定一个值。然后不断重复这个过程来确定一系列的值。</p>
<h4 id="Paxos-算法的执行流程"><a href="#Paxos-算法的执行流程" class="headerlink" title="Paxos 算法的执行流程"></a>Paxos 算法的执行流程</h4><p>基于以上思想，Paxos 最后设计出可落地的执行流程。关于 Paxos 算法的执行流程可以看下这位网友的文章，浅显易懂 <a href="https://www.zhihu.com/question/19787937">Paxos算法的执行流程</a> 这里就不再赘述了。</p>
<h2 id="算法存在的问题"><a href="#算法存在的问题" class="headerlink" title="算法存在的问题"></a>算法存在的问题</h2><p>读到这里相信大家都对 Paxos 的执行流程有一个大概的印象了，那么这个流程中会引发两个问题：</p>
<ol>
<li>存在陷入不断循环的风险：Paxos 是一个“不断循环”的2PC。在P1C或者P2C阶段，算法都可能失败，每次失败就要再重新执行一遍算法流程，在极端情况下可能出现不断循环的情况。</li>
<li>存在性能问题：每确定一个值，至少需要两次通信（两个阶段，两个网络来回）+ 两次写盘。</li>
</ol>
<p>为了解决这两个问题 <strong>Multi Paxos 算法</strong>应运而生。</p>
<h2 id="Multi-Paxos算法"><a href="#Multi-Paxos算法" class="headerlink" title="Multi Paxos算法"></a>Multi Paxos算法</h2><p>Multi Paxos算法并不是一个全新的算法，它只是在 Paxos 算法的基础上进行了一些改进，接下来我们看下它是如何解决上面两个问题的。</p>
<h3 id="解决不断循环"><a href="#解决不断循环" class="headerlink" title="解决不断循环"></a>解决不断循环</h3><p>这个问题的本质<strong>是多个客户端写多个机器，会导致并发冲突很高</strong>，所以如果减少并发冲突那就可以解决这个问题了。</p>
<h4 id="创建一个-Leader"><a href="#创建一个-Leader" class="headerlink" title="创建一个 Leader"></a>创建一个 Leader</h4><p><strong>为了减少并发冲突，可以变多写为单写</strong>，选出一个Leader，其他机器收到写请求，都把写请求转发给Leader；或者让客户端把写请求都发给Leader。这样就可以避免<strong>写并发</strong>了。当然由于网络原因可能产生 <strong>脑裂</strong>，也就是有多个 Leader ，但是即使有多个 Leader 也不会影响数据的正确性，只是增加了发生并发的可能性而已。</p>
<p>说到这里就可能要说下 Leader 选举的两种常用方法了。</p>
<h4 id="无租约的-Leader-选举"><a href="#无租约的-Leader-选举" class="headerlink" title="无租约的 Leader 选举"></a>无租约的 Leader 选举</h4><p>选举流程如下：</p>
<ol>
<li>每个节点有一个编号，选取编号最大的节点为Leader；</li>
<li>每个节点周期性地向其他节点发送心跳，假设周期为T ms；</li>
<li>如果一个节点在最近的2 T ms内还没有收到比自己编号更大的节点发来的心跳，则自己变为Leader；</li>
<li>如果一个节点不是Leader，则收到请求之后转发给Leader。</li>
</ol>
<h4 id="有租约的-Leader-选举"><a href="#有租约的-Leader-选举" class="headerlink" title="有租约的 Leader 选举"></a>有租约的 Leader 选举</h4><p><strong>严格保证任意时刻只能有一个leader</strong>，也就是所谓的“租约”。租约的意思是在一个限定的期限内，某台机器一直是 Leader。即使这个机器宕机，Leader也不能切换。必须等到租期到期之后，才能开始选举新的Leader。这种方式会带来短暂的不可用，但保证了任意时刻只会有一个Leader。</p>
<h3 id="解决性能问题"><a href="#解决性能问题" class="headerlink" title="解决性能问题"></a>解决性能问题</h3><p>选举出 Leader 之后对 2PC 进行了优化，基本思路是当一个节点被确认为Leader之后，它先广播一次Prepare，一旦超过半数同意 （防止有另一个 Leader ），之后对于收到的每条日志直接执行应用操作。这样就减少了一次询问的流程。</p>
<p>如果同时还有另一个 Leader 怎么办呢？新的Leader肯定会先发起Prepare，新 Leader 的编号肯定更大。这时旧的 Leader 的广播肯定会失败，旧的 Leader 会自己转变成一个普通的Acceptor，新的Leader把旧的顶替掉了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性算法-Raft</title>
    <url>/posts/abf4a6b7.html</url>
    <content><![CDATA[<p>Paxos 算法虽然在一段时间内已经成了一致性算法的代名词。但是它也是出了名的艰深晦涩，并且当时基于 Paxos 的成熟工程少之又少。在这种情况下就有人设计了 Raft 算法，Raft 算法将”可理解性”放在了第一位。下面就让我们看下 Raft 算法的运行流程。</p>
<span id="more"></span>

<p>Raft 算法总共有三个阶段：阶段一，选举 Leader；阶段二，同步数据；阶段三，崩溃恢复。下面详细讲述这三个阶段。</p>
<h2 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h2><p>任何一个节点有且仅有三种状态：Leader、Follower、Candidate。Candidate是一个中间状态，是正在选举中，选举结束后要么切换到 Leader，要么切换到Follower。</p>
<ol>
<li>初始时，所有机器处于Follower状态，等待Leader的心跳消息（一个机器成为Leader之后，会周期性地给其他Follower发心跳）。很显然，此时没有Leader，所以收不到心跳消息。</li>
<li>当Follower在给定的时间（比如2000ms）内收不到Leader的消息，就会认为Leader宕机，也就是选举超时。然后，随机睡眠0～1000ms之间的一个值（为了避免大家同时发起选举），把自己切换成Candidate状态，发起选举，每个节点都会维护一个编号起个名字叫 term，term从 1 开始递增，选举的时候如果对方的 term 大于自己的那么就同意它当选 Leader 。</li>
<li>选举结束，自己变成Leader或者Follower。</li>
<li>对于Leader，发现有更新的Leader存在，自己主动退位，变成Follower。</li>
</ol>
<p>关于第四点你可能有些疑问，为什么会有多个 Leader 的情况？这是可能是因为网络抖动导致网络分区形成了 <strong>脑裂</strong> 的问题。<strong>因为 Raft 算法与 Paxos 不同，Raft 规定，同一时间同一个网络分区内只能有一个 Leader 。</strong>那如何判断哪个 Leader 是比较新的呢？这个时候就要了解下 Raft 是如何存储数据的了。</p>
<h3 id="Raft-如何存储数据"><a href="#Raft-如何存储数据" class="headerlink" title="Raft 如何存储数据"></a>Raft 如何存储数据</h3><p>下图就是 Raft 算法需要存储的数据，各个字段的意义如下：</p>
<p><img src="https://gitee.com/biyanwenhante/picture-bed/raw/master/image-20220218070635344.png" alt="image-20220218070635344"></p>
<h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><p>term 是指写入日志的Leader所在的“任期”, 比如说第一个被选为 Leader 节点，它的 term 就是1，当它宕机了，选出了第二个 Leader 节点，那这个节点的 term 就是 2，term 是递增的。 每当 Leader 向 Follower 同步数据时就会携带着自己的 term ，这样 Follower 就可以记录当前这个数据是第几任 Leader 发过来的。</p>
<p><strong>意义：</strong> <strong>可以解决Leader的“脑裂”问题。</strong>假设现在因为网络分区导致整个集群中同时存在两个 Leader ，一个是旧的，一个是新的，旧的 Leader 的 term  = 4，新的 term = 5。当网络分区的情况消失时两个 Leader 就会相遇，这时新、老Leader都会向Follower发送数据。但当老的Leader向其他所有Follower发送数据时，Follower发现它发过来的日志里面term=4，就知道它是过期的Leader，就会拒绝执行写入操作，同时会反馈给老的Leader说，你已经过期了！老的Leader知道自己过期了，会自动退位，变成Follower。从而解决了“脑裂”问题，使得任何一个时刻，只可能有一个Leader有效！</p>
<p><strong>如何保证 Leader 的 term 永远是最大的？</strong>term并不是存放在一个中央存储里面，而是每个节点都保存了一个term的值。因为网络延迟问题，某些节点上面term的值可能是过期的。假设当前term的真实有效值是5，但是某些节点上面term的值没有来得及更新，其term=4。这时term=4 的节点被选为Leader了，那不就出问题了吗？答案是不可能出现这个情况。因为选举的时候是要多数派（超过半数的节点）同意的，意味着在多数派里面一定有一个节点保存了最新的term的值。而在选举的时候，是选日志最新的节点作为Leader。所以，如果一个节点的term=4（过期的），就不可能被选为Leader。如果一个节点被选为了Leader，其term值一定是当前最大的，也就是最新的。</p>
<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>这个字段就很好理解了，就是消息的索引，也是自增的。</p>
<h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>这个字段就是用来存储真实数据的。</p>
<h4 id="commitIndex"><a href="#commitIndex" class="headerlink" title="commitIndex"></a>commitIndex</h4><p>一旦一条日志被认定是“commit”，这条日志将不能被改变，不能被删除！很显然，任何一条日志要么是commit状态，要么是uncommit状态（暂时还不确定，可能过一会儿就变成了commit状态）。</p>
<p>日志的commit设计<strong>应用了一个类似TCP协议中的技巧</strong>，可称为递增式的commit。假设commitIndex=7，表示不仅index=7的日志是commit状态，所有index＜7的日志也都是commit状态。</p>
<p>这会带来两个好处：</p>
<ol>
<li>维护一个全局变量commitIndex即可。不需要为每条日志都维护一个 commit 或 uncommit 状态。</li>
<li>提高性能。Follower不需要逐条日志地反馈Leader，哪一条commit了，则哪一条uncommit。</li>
</ol>
<h2 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h2><p>Leader成功选举出来后，接下来进入第二个阶段，正常的数据同步阶段。当客户端向节点写入数据的时候，如果写入数据的节点不是 Leader 节点，那么该节点就会把这个请求转发给 Leader 去执行。Leader 会先在自己的节点记录这个数据，然后再将数据发送给所有节点，如果有半数节点都返回成功，那么 Leader 就会返回给客户端写入数据成功的信息。</p>
<p>在这个过程中有两个关键的“日志一致性”保证，保证Leader和Follower日志序列完全一模一样：</p>
<ol>
<li>对于两个日志序列里面的两条日志，如果其index和term都相同，则日志的内容必定相同。</li>
<li>对于两个日志序列，如果在index=M处的日志相同，则在M之前的所有日志也都完全相同。</li>
</ol>
<p>所以，如果 Follower 发现自己的日志中，某个index位置和Leader发过来的不一样，则删除index之后的所有日志，然后从index的位置同步接下来的日志。</p>
<h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>当Leader宕机之后，选出了新的Leader，其他的Follower要切换到新的Leader。</p>
<p>Follower是被动的，其并不会主动发现有新的Leader上台了；而是新的Leader上台之后，会马上给所有的 Follower 发一个同步数据的请求，只不过这个请求没有包含客户端数据，只是为了同步 term ，这样每个Follower都会将自己的term更新到最新的term。这样旧的Leader即使活过来了，也没有机会再写入日志。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算学习笔记</title>
    <url>/posts/25cb8793.html</url>
    <content><![CDATA[<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与</td>
<td>a &amp; b</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
<td>a | b</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>~a</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>a ^ b</td>
</tr>
</tbody></table>
<h4 id="逻辑运算结果集"><a href="#逻辑运算结果集" class="headerlink" title="逻辑运算结果集"></a>逻辑运算结果集</h4><span id="more"></span>

<p>逻辑运算相对简单，下面用一个表格来展示运算逻辑和结果。</p>
<p>ps： 前两列为 A、B 的取值； A &amp; B 只有两个值都为1的时候结果才唯一；A|B 只要两个中有一个为1结果就为1；A^B 如果两个值不一样时结果为1；~A 取反。</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A&amp;B</th>
<th>A|B</th>
<th>A^B</th>
<th>~A</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左位移</td>
<td>a &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
<td>b &gt;&gt; 4</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右位移</td>
<td>x &gt;&gt;&gt;2</td>
</tr>
</tbody></table>
<h4 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h4><p><code>&lt;&lt;</code>  为左移运算符。它的作用是将二进制数字整体向左移动；<strong>在符号位不变的情况</strong>下每左移一位相当于在原有基础上乘以2。</p>
<p>下图为左移运算的示意图，高位益处则舍弃，低位不够则补零。</p>
<p><img src="https://s2.loli.net/2022/01/09/v4xuoJ17RNWYXIA.png" alt="image-20220109165615031"></p>
<h4 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h4><p><code>&gt;&gt;</code> 与左移运算符相反，它的作用是将二进制数字整体向右移动；每次右移相当于原来的数字除以2；右移运算符对正负数有不同的策略，如果是正数，最高位会补 0 ，如果是负数最高位补 1，<strong>这样可以保证正数做完运算还是正数，负数做完运算还是负数</strong>。</p>
<p><img src="https://s2.loli.net/2022/01/09/OjUpcdlGsDZk8bu.png" alt="image-20220109171054303"></p>
<h4 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h4><p><code>&gt;&gt;&gt;</code> 为无符号右移运算符。运算逻辑与右移运算符相同，唯一的不同是它只会在最高位补 0，这样可能导致负数变正数；<strong>在符号位不变的情况</strong>下每右移一位相当于在原有基础上除以2。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/posts/ddb92a08.html</url>
    <content><![CDATA[<h2 id="对象已死？-判断对象是否可以回收"><a href="#对象已死？-判断对象是否可以回收" class="headerlink" title="对象已死？(判断对象是否可以回收)"></a>对象已死？(判断对象是否可以回收)</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>reference类型的数据中存储的数值代表的是另一块内存的起始地址</p>
<ul>
<li>强引用：代码中的引用赋值 例如 new对象；意义：对象不会被回收</li>
<li>软引用：还有用非必须的对象；意义：在系统将要发生内存溢出前回收</li>
<li>弱引用：非必须对象；意义：每次垃圾回收时都会被清理</li>
<li>虚引用：最弱的一种引用；意义：可以让一个对象被回收时收到一个系统通知</li>
</ul>
  <span id="more"></span></li>
</ul>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul>
<li>在对象中添加一个引用计数器，被引用加一，引用失效减一，为零就不会再使用可以回收</li>
<li>优点：原理简单，效率高</li>
<li>缺点：实用性不强，例如 很难解决对象间的互相循环引用的问题</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li><p>判断某个对象到GC Roots间有没有引用链相连，如果没有就说明对象不可达、不再使用可以回收</p>
</li>
<li><p>GC Roots</p>
<ul>
<li>虚拟机栈的本地变量表中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(Native方法)引用的对象</li>
<li>java虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象，类加载器</li>
<li>同步锁持有的对象</li>
<li>反应虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
</li>
</ul>
<h3 id="生存还是死亡-判断对象是否真的能被回收"><a href="#生存还是死亡-判断对象是否真的能被回收" class="headerlink" title="生存还是死亡(判断对象是否真的能被回收)"></a>生存还是死亡(判断对象是否真的能被回收)</h3><ul>
<li>至少要经历两次标记(判断)，如果第一次被标记成不可达，但是在第二次标记前又与GC Roots建立了链接就不会被清理</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>《java虚拟机规范》不强制方法区实现垃圾收集</li>
<li>方法区垃圾收集性价比比较低</li>
<li>主要回收废弃的常量和不再使用的类型（类型指加载到内存中的Class）</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="引用计数式垃圾收集（直接垃圾收集）"><a href="#引用计数式垃圾收集（直接垃圾收集）" class="headerlink" title="引用计数式垃圾收集（直接垃圾收集）"></a>引用计数式垃圾收集（直接垃圾收集）</h3><h3 id="追踪式垃圾收集（间接垃圾收集）（主流）"><a href="#追踪式垃圾收集（间接垃圾收集）（主流）" class="headerlink" title="追踪式垃圾收集（间接垃圾收集）（主流）"></a>追踪式垃圾收集（间接垃圾收集）（主流）</h3><ul>
<li><p>分代收集理论</p>
<p>设计原则：收集器应该将java堆划分出不同区域，然后将回收对象依据其年龄分配到不同的区域之中存储</p>
<ul>
<li><p>弱分代假说：绝大多数对象都是朝生夕死的</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象越你难以死亡</p>
</li>
<li><p>分代</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
</li>
<li><p>跨分代引用假说：存在相互引用关系的对象应该倾向于同生同死，跨代引用占比较少。</p>
<ul>
<li><p>存在问题：当扫描新生代对象时如果有跨代引用还需要扫描整个老年代，成本较高</p>
<ul>
<li>解决办法：新生代建立一个全局数据结构（记忆集），这个结构将老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用。Minor GC时只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，而不用扫描整个老年代</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标记-清除算法：标记后清除被标记的对象</p>
<ul>
<li>缺点：1、执行效率不稳定（受要标记的目标对象数量的限制）；2、内存空间碎片化（产生不连续的内存碎片）</li>
</ul>
</li>
<li><p>标记-复制算法：将内存划分为大小相等的两块，每次只用其中一块，当内存用完了就将存活对象复制到另一块，然后将已使用的内存一次清理掉</p>
<ul>
<li>缺点：空间浪费太严重</li>
<li>新生代优先采用此算法，而老年代不会使用这种方法，因为新生代98%对象都是朝生夕死的，这种情况实现简单、效率高</li>
</ul>
</li>
<li><p>标记-整理算法：先标记，让存活对象都移动到内存一端，然后清理掉边界以外的内存</p>
</li>
</ul>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul>
<li>单线程收集器</li>
<li>优点：简单高效、内存消耗最小</li>
<li>缺点：工作时必须“Stop The World”，用户体验差</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul>
<li>Serial收集器多线程并行版本</li>
<li>HotSpot虚拟机中第一款退出历史舞台的垃圾收集器，只能和CMS配合使用而CMS将会替代CMS</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul>
<li>多线程，基于标记-复制算法</li>
<li>设计目标：达到一个可控的吞吐量（也就是控制垃圾回收所占用的时间）</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul>
<li>Serial的老年代版本 </li>
<li>单线程，基于标记整理算法</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><ul>
<li>Parallel Scavenge收集器老年代版本</li>
<li>多线程，基于标记-整理算法</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li><p>目标：为了获取最短回收停顿时间</p>
</li>
<li><p>多线程，基于标记-清除算法</p>
</li>
<li><p>缺点：1、处理器资源敏感，会占用一部分资源导致程序变慢，总吞吐量降低。2、无法处理浮动垃圾，可能导致full gc发生。3、无法处理空间碎片，只能依靠full gc</p>
<p>浮动垃圾：CMS标记和清理阶段用户线程会同时运行并产生新的垃圾，因为有些垃圾在标记后产生所以本次无法清理，只能等到下次。</p>
</li>
</ul>
<h3 id="Garbage-First收集器（G1）"><a href="#Garbage-First收集器（G1）" class="headerlink" title="Garbage First收集器（G1）"></a>Garbage First收集器（G1）</h3><ul>
<li><p>将堆内存划分为多个大小相等的独立区域（Region），每个区域都可以根据需要扮演新生代的Eden空间、Survivor空间或老年代空间，每次回收时G1会判断那块回收性价比最高，收益最大；Region中设有Humongous区域，用来存储大对象（超过Region一半的对象），而超级大对象会被存放在多个连续的Humongous区域</p>
</li>
<li><p>与CMS比较</p>
<ul>
<li>优势：1、不会产生垃圾碎片；2、创新性设计带来较多红利：可以指定最大停顿时间，分区域的内存布局，按收益动态确定回收集</li>
<li>弱势：1、占用内存多、负载率高</li>
</ul>
</li>
</ul>
<h2 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h2><h3 id="jps：虚拟机进程状况工具，主要用来查看进行的唯一ID"><a href="#jps：虚拟机进程状况工具，主要用来查看进行的唯一ID" class="headerlink" title="jps：虚拟机进程状况工具，主要用来查看进行的唯一ID"></a>jps：虚拟机进程状况工具，主要用来查看进行的唯一ID</h3><h3 id="jstat-虚拟机统计信息监视工具，主要用于查看虚拟机各种运行状态信息"><a href="#jstat-虚拟机统计信息监视工具，主要用于查看虚拟机各种运行状态信息" class="headerlink" title="jstat: 虚拟机统计信息监视工具，主要用于查看虚拟机各种运行状态信息"></a>jstat: 虚拟机统计信息监视工具，主要用于查看虚拟机各种运行状态信息</h3><h3 id="jinfo：java配置信息工具，主要使用-sysprops-打印System-getProperties-的内容"><a href="#jinfo：java配置信息工具，主要使用-sysprops-打印System-getProperties-的内容" class="headerlink" title="jinfo：java配置信息工具，主要使用-sysprops 打印System.getProperties()的内容"></a>jinfo：java配置信息工具，主要使用-sysprops 打印System.getProperties()的内容</h3><h3 id="jmap：java内存映像工具，主要用于生成堆转储快照"><a href="#jmap：java内存映像工具，主要用于生成堆转储快照" class="headerlink" title="jmap：java内存映像工具，主要用于生成堆转储快照"></a>jmap：java内存映像工具，主要用于生成堆转储快照</h3><h3 id="jhat：虚拟机堆转储快照分析工具，图形化工具更适合这个工作-所以这个命令用处不大"><a href="#jhat：虚拟机堆转储快照分析工具，图形化工具更适合这个工作-所以这个命令用处不大" class="headerlink" title="jhat：虚拟机堆转储快照分析工具，图形化工具更适合这个工作 所以这个命令用处不大"></a>jhat：虚拟机堆转储快照分析工具，图形化工具更适合这个工作 所以这个命令用处不大</h3><h3 id="jstack：java堆栈跟踪工具，主要用于生成虚拟机当前时刻线程快照，例如可以查看没有相应的线程在后台干什么"><a href="#jstack：java堆栈跟踪工具，主要用于生成虚拟机当前时刻线程快照，例如可以查看没有相应的线程在后台干什么" class="headerlink" title="jstack：java堆栈跟踪工具，主要用于生成虚拟机当前时刻线程快照，例如可以查看没有相应的线程在后台干什么"></a>jstack：java堆栈跟踪工具，主要用于生成虚拟机当前时刻线程快照，例如可以查看没有相应的线程在后台干什么</h3><h2 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h2><h3 id="在经典分代设计下，新生对象通常会分配在新生代中，少数情况下也可能直接分配在老年代"><a href="#在经典分代设计下，新生对象通常会分配在新生代中，少数情况下也可能直接分配在老年代" class="headerlink" title="在经典分代设计下，新生对象通常会分配在新生代中，少数情况下也可能直接分配在老年代"></a>在经典分代设计下，新生对象通常会分配在新生代中，少数情况下也可能直接分配在老年代</h3><h3 id="对象优先在新生代Eden区域分配"><a href="#对象优先在新生代Eden区域分配" class="headerlink" title="对象优先在新生代Eden区域分配"></a>对象优先在新生代Eden区域分配</h3><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h3><ul>
<li>Eden中的对象经过一次GC仍然存活并且能被Survivor容纳就会被转移到Survivor中，并将对象年龄设置为1，对象在Survivor中每熬过一次GC就增加一岁，年龄增加到15（默认 可以设置）时进入老年代</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><ul>
<li>HotSpot虚拟机并不是永远等到对象年龄达到标准才晋升到老年代，如果Survivor空间中的相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代</li>
</ul>
<h2 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h2><h3 id="垃圾收集器工作内容"><a href="#垃圾收集器工作内容" class="headerlink" title="垃圾收集器工作内容"></a>垃圾收集器工作内容</h3><ul>
<li>垃圾收集、堆内存的管理与布局、对象的分配、与解释器的协作、与编译器的协作，与监控子系统的协作等等</li>
</ul>
<h3 id="应用只要运行数分钟甚至数秒，只要虚拟机能正确分配内存，在堆耗尽之前就会退出"><a href="#应用只要运行数分钟甚至数秒，只要虚拟机能正确分配内存，在堆耗尽之前就会退出" class="headerlink" title="应用只要运行数分钟甚至数秒，只要虚拟机能正确分配内存，在堆耗尽之前就会退出"></a>应用只要运行数分钟甚至数秒，只要虚拟机能正确分配内存，在堆耗尽之前就会退出</h3><ul>
<li>Epslion收集器，不进行垃圾回收，但负载极小</li>
</ul>
<h3 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h3><ul>
<li><p>应用程序的关注点</p>
<ul>
<li>吞吐量</li>
<li>延迟</li>
<li>内存占用</li>
</ul>
</li>
</ul>
<h3 id="虚拟机及垃圾收集器日志"><a href="#虚拟机及垃圾收集器日志" class="headerlink" title="虚拟机及垃圾收集器日志"></a>虚拟机及垃圾收集器日志</h3><ul>
<li>1、查看GC基本信息：jdk9以前 -XX:+PrintGC,9以后 -Xlog:gc</li>
<li>2、查看GC详细信息：9以前 -XX:+PrintGCDetails,9以后 -X-log:gc*</li>
<li>3、查看GC前后堆、方法区可用容量变化：9以前-XX:+PrintHeapAtGC,9以后 -Xlog:gc+heap=debug</li>
<li>4、查看GC过程中用户线程并发时间以及停顿的时间：9以前-XX:Print-GCApplicationConcurrentTime 及 -XX:+PrintGCApplicatiionStoppedTime,9以后 -Xlog:safepoint</li>
<li>只列出一些常用的命令</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的Web应用攻击手段</title>
    <url>/posts/bd83d0b7.html</url>
    <content><![CDATA[<h2 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1.XSS攻击"></a>1.XSS攻击</h2><p>XSS攻击即跨站点脚本攻击（Cross Site Script），指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p>
<span id="more"></span>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>1.1 反射型</p>
<p>攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的</p>
</li>
<li><p>1.2 持久型</p>
<p>黑客提交含有恶意脚本的请求，保存在被攻击的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击的目的</p>
</li>
</ul>
<h3 id="防护手段"><a href="#防护手段" class="headerlink" title="防护手段"></a>防护手段</h3><ul>
<li><p>1.3消毒</p>
<p>XSS攻击者一般都是通过在请求中嵌入恶意脚本达到攻击的目的，这些脚本是一般用户输入中不使用的，如果进行过滤和消毒处理，即对某些html危险字符转义就可以让绝大部分攻击失败</p>
</li>
<li><p>1.4HttpOnly</p>
<p>浏览器禁止页面JavaScript访问带有HttpOnly属性的Cookie，可以防止Cookie中的数据被窃取</p>
</li>
</ul>
<h2 id="2-注入攻击"><a href="#2-注入攻击" class="headerlink" title="2.注入攻击"></a>2.注入攻击</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>2.1 SQL注入攻击</p>
<p>攻击者在HTTP请求中注入恶意SQL命令（drop table users;），服务器用请求参数构造数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p>
</li>
<li><p>2.2 OS注入攻击</p>
</li>
</ul>
<h3 id="防护手段-1"><a href="#防护手段-1" class="headerlink" title="防护手段"></a>防护手段</h3><ul>
<li><p>2.3 消毒</p>
<p>通过正则匹配，过滤请求数据中可能注入的SQL</p>
</li>
<li><p>2.4 参数绑定</p>
<p>使用预编译手段，绑定参数是最好的防SQL注入方法。目前许多数据访问层框架，如IBatis，Hibernate等，都实现SQL预编译和参数绑定，攻击者的恶意SQL会被当做SQL的参数，而不是SQL命令被执行。</p>
</li>
</ul>
<h2 id="3-CSRF攻击"><a href="#3-CSRF攻击" class="headerlink" title="3.CSRF攻击"></a>3.CSRF攻击</h2><p>攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易、发表评论等；<br>CSRF的主要手法是利用跨站请求，在用户不知情的情况下，以用户的身份伪造请求。其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。</p>
<h3 id="防护手段-2"><a href="#防护手段-2" class="headerlink" title="防护手段"></a>防护手段</h3><ul>
<li><p>3.1 Token验证</p>
<p>通过在请求参数中增加随机数的办法来阻止攻击者获得所有请求参数：在页面表单中增加一个随机数作为Token，每次响应页面的Token都不相同，从正常页面提交的请求会包含该Token值，而伪造的请求无法获得该值，服务器检查请求参数中Token的值是否存在并且正确以确定请求提交者是否合法</p>
</li>
<li><p>3.2 验证码</p>
<p>验证码则更加简单有效；<br>请求提交时，需要用户输入验证码，以避免在用户不知情的情况下被攻击者伪造请求。但是输入验证码是一个糟糕的用户体验，所以请在必要时使用，</p>
</li>
<li><p>3.3 Referer check</p>
<p>HTTP请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其是否合法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>指令详解-寻址方式</title>
    <url>/posts/def90db1.html</url>
    <content><![CDATA[<h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>简单来说就是根据地址码取数据。</p>
<p>指令中通常会增加一个寻址特征字段，这个字段就是告诉操作系统如何取数据的，如图：因为不同寻址方式的实现不同，所以地址码中存储的并不一定是真实的数据地址，所以这里用形式地址代替。</p>
<p><img src="https://s2.loli.net/2022/01/08/buwDO8aYx3I5npg.png" alt="image-20220108103344939"></p>
<p>根据寻址特征的不同通常将寻址方式分为以下几类。</p>
<span id="more"></span>

<h3 id="立即寻址特征"><a href="#立即寻址特征" class="headerlink" title="立即寻址特征"></a>立即寻址特征</h3><p>定义：地址码存的就是操作数本身。</p>
<p><img src="https://s2.loli.net/2022/01/08/v6yKge7ZaRG1bDd.png" alt="image-20220108111245946"></p>
<h3 id="直接寻址特征"><a href="#直接寻址特征" class="headerlink" title="直接寻址特征"></a>直接寻址特征</h3><p>定义：地址码存储的是操作数的内存地址。</p>
<p><img src="https://s2.loli.net/2022/01/08/KwNxtdfUGmeLM39.png" alt="image-20220108111313336"></p>
<h3 id="隐含寻址特性"><a href="#隐含寻址特性" class="headerlink" title="隐含寻址特性"></a>隐含寻址特性</h3><p>定义：运算所需的操作数地址并没有都存储在指令中。</p>
<p>例如，单地址指令中就不是明显地在地址字段中指出第二操作数的地址，而是规定累加器ACC作为第二操作数，指令格式明显指出的仅是第一操作数的地址。因此，累加器ACC对单地址指令格式来说是隐含地址。</p>
<p><img src="https://s2.loli.net/2022/01/08/l4BnqWbNGPe51tQ.png" alt="image-20220108111457917"></p>
<h3 id="间接寻址特性"><a href="#间接寻址特性" class="headerlink" title="间接寻址特性"></a>间接寻址特性</h3><p>定义：操作数需要通过其他指令中存储的地址得到。</p>
<p>如图所示，指令中的形式地址 A 存储着 EA 操作数的地址，通过这个地址才能间接的找到 EA 的操作数。</p>
<p><img src="https://s2.loli.net/2022/01/08/8TuMsyR91XzCieU.png" alt="image-20220108112320965"></p>
<p>ps: 间接地址可以有多个，简单说可能需要多次跳转才能找到 EA 这个操作数。</p>
<h3 id="寄存器间接寻址特征"><a href="#寄存器间接寻址特征" class="headerlink" title="寄存器间接寻址特征"></a>寄存器间接寻址特征</h3><p>定义：地址码中存储着寄存器的编号，指令所需的操作数的地址存储在寄存器中。</p>
<p>如图 ：需要先根据地址码中的寄存器地址找到寄存器，之后才能根据寄存器中存储的操作数地址找到操作数。</p>
<p><img src="https://s2.loli.net/2022/01/08/UQka8cPq9oByJDz.png" alt="image-20220108121433750"></p>
<h3 id="基址寻址特征"><a href="#基址寻址特征" class="headerlink" title="基址寻址特征"></a>基址寻址特征</h3><p>定义：由一个寄存器存储一个基础内存地址，然后指令中的地址码存储着一个基于基础内存地址的偏移量，真实的操作数地址等于基础内存地址加上偏移量。</p>
<p>如图，需要在指令中维护一个寄存器的地址，寻址的时候先从寄存器中拿到基础内存地址，然后再加上内存地址的偏移量，就可以找到操作数了。</p>
<p><img src="https://s2.loli.net/2022/01/08/k7enaVYZXgcFsOx.png" alt="image-20220108122536632"></p>
<p>特点如下：</p>
<ul>
<li>可扩大寻址范围（基础内存地址的位数大于形式地址的位数）；</li>
<li>用户不必考虑自己的程序存于主存的哪一空间区域；</li>
<li>基础内存地址由操作系统维护，用户只能更改形式地址；</li>
</ul>
<h3 id="变址寻址特征"><a href="#变址寻址特征" class="headerlink" title="变址寻址特征"></a>变址寻址特征</h3><p>与基址寻址特别相像，最大的不同是内存地址的偏移量是不变的，可变基础内存地址是可变的。</p>
<p><img src="https://s2.loli.net/2022/01/08/wZb5iAOKRzcMBJt.png" alt="image-20220108123738283"></p>
<p>特点：</p>
<ul>
<li>可扩大寻址范围（基础内存地址的位数大于形式地址的位数）；</li>
<li>方便处理数组问题和循环程序。例如形式地址 A 为数组的首地址，通过不断改变可变基础地址就能够很容易形成数组中任意数据的地址。</li>
</ul>
<h3 id="相对寻址特征"><a href="#相对寻址特征" class="headerlink" title="相对寻址特征"></a>相对寻址特征</h3><p>相对寻址是把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址。</p>
<p><img src="https://s2.loli.net/2022/01/08/N1e3ZTXhdYQ9OBg.png" alt="image-20220108222644952"></p>
<p>优点：相对寻址的优点是操作数的地址不是固定的，它随着PC的值得变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，相对寻址广泛应用于转移指令。</p>
<h3 id="堆栈寻址特征"><a href="#堆栈寻址特征" class="headerlink" title="堆栈寻址特征"></a>堆栈寻址特征</h3><p>堆栈是存储器（或专用寄存器组）中一块特定的按“先进后出（LIFO）”原则管理的存储区，该存储区中被读、写单元的地址是用特定的寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈和软堆栈两种。</p>
<p>寄存器堆栈又称为<strong>硬堆栈</strong>。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为<strong>软堆栈</strong>。</p>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>
<p><img src="https://s2.loli.net/2022/01/08/DajzUl8HvnG1JE6.png" alt="image-20220108223757637"></p>
<h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>执行完当前指令之后，如何寻找下一条指令的地址。</p>
<h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><p>当前指令的地址加一就是下一条指令的地址。</p>
<h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><p>下一条指令的地址由本条指令的地址码给出。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>指令详解-地址码</title>
    <url>/posts/adb2ba17.html</url>
    <content><![CDATA[<h2 id="指令是什么："><a href="#指令是什么：" class="headerlink" title="指令是什么："></a>指令是什么：</h2><p>可以将指令当做一种编程语言，表现形式为一串二进制码，作用是能让计算机按照指令去工作。</p>
<p>指令由两部分组成，操作码和地址码，下面我们着重看下<strong>地址码</strong>。</p>
<span id="more"></span>

<h2 id="操作码（OP）："><a href="#操作码（OP）：" class="headerlink" title="操作码（OP）："></a>操作码（OP）：</h2><p>用于表明这条指令的作用。</p>
<h2 id="地址码（A）："><a href="#地址码（A）：" class="headerlink" title="地址码（A）："></a>地址码（A）：</h2><p>存储内存地址，用来寻找内存中的数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据地址码的数量进行分类。</p>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><p><img src="https://s2.loli.net/2022/01/06/XkvMpVyrgucfNla.png" alt="image-20220106100336187"></p>
<p>其中A1 第一个操作数的地址、A2 第二个操作数的地址、A3 保存计算结果、A4 下一条待执行指令的地址。<br>公式：（A1）OP （A2）—&gt; A3； A4 指向下一条指令。<br>特点：表意直观，可以明确指出下一条指令的地址，但是长度太大，实际应用中很少采用这种格式。</p>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><p><img src="https://s2.loli.net/2022/01/06/e6oJ41ltTj7Kv3y.png" alt="image-20220106100731815"></p>
<p>其中A1 第一个操作数的地址、A2 第二个操作数的地址、A3 保存计算结果</p>
<p>公式：（A1）OP （A2）—&gt; A3。<br>这里是没有存储下一条指令的地址，因为指令都是顺序排布的，所以默认下一条指令地址为 （PC）+1 —&gt; PC 。 PC 为程序计数器。<br>特点：指令长度太长，执行一次指令要四次访存，取指令一次，取操作数两次，存结果一次，操作数不会被破坏，因为会用一个单独的地址存储计算结果。</p>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><p><img src="https://s2.loli.net/2022/01/06/6pStYCkeoOlqy2u.png" alt="image-20220106101015294"></p>
<p>用其中一个地址码来保存结果，公式：（A1）OP （A2）—&gt; A1。（PC）+1 —&gt; PC。<br>特点：执行一次指令要四次访存，取指令一次，取操作数两次，存结果一次。执行完成后计算结果会覆盖一个操作数，所以操作数会被破坏。</p>
<h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><p><img src="https://s2.loli.net/2022/01/06/rBALognIxNdZEjK.png" alt="image-20220106101121663"></p>
<p>一般用于累加计算器（Acc），公式：（Acc）OP （A1） —&gt; Acc。（PC）+1 —&gt; PC。<br>特点：执行一次指令只需访存两次，取指令一次，取操作数一次。被操作数和运算结果都放在累加寄存器中，所以对于被操作数的读取和存入都不需要访存。</p>
<h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p><img src="https://s2.loli.net/2022/01/06/EmJ8D2pGORQ4K9n.png" alt="image-20220106101425810"></p>
<p>特点：一般运用于堆栈计算机中，参与运算的操作数从栈顶弹出，运算后将结果压入堆栈中。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>指令详解-操作码</title>
    <url>/posts/94f9446a.html</url>
    <content><![CDATA[<h2 id="定长编码"><a href="#定长编码" class="headerlink" title="定长编码"></a>定长编码</h2><p>每条指令的操作码都是固定长度。当操作码是 n 位时，指令最多有 2^n 条。<br>优点：计算机的硬件设计简单，朱令译码和执行速度快。<br>缺点：当指令数量增多、指令字单独为操作码划分出固定的多位后，留给表示操作数地址的位数会严重不足。<br>适用环境：适用于字长较长的计算机系统，如 32 位及以上。</p>
<span id="more"></span>

<p>如图：无论有几个地址码都不会影响操作码的长度。</p>
<p><img src="https://s2.loli.net/2022/01/07/XzuvCTyoSpdbh2V.png" alt="image-20220107125003587"></p>
<h2 id="变长编码"><a href="#变长编码" class="headerlink" title="变长编码"></a>变长编码</h2><p>每条指令的操作码的长度不是固定的，是可变的。之所以有变长编码是因为这会让系统更灵活，可以通过变动操作码的长度来保证地址码长度和指令长度不变。<br>如图：四地址指令和三地址指令的指令长度和地址码的长度是一样的。</p>
<p><img src="https://s2.loli.net/2022/01/07/EyUX3z4txl7pV5c.png" alt="image-20220107125232359"></p>
<p>优点：在拥有比较短的指令字长的系统中，既能表示出比较多的指令条数又能尽量满足操作数地址的要求。<br>缺点：计算机的硬件设计复杂，指令译码和执行速度较慢。<br>适用环境：适用于字长较短的计算机系统，如 16 位及以下。</p>
<h3 id="扩展操作码"><a href="#扩展操作码" class="headerlink" title="扩展操作码"></a>扩展操作码</h3><p>为了保证不同类型指令的地址码和指令的长度不变，我们需要增加操作码的长度，这个操作就是扩展操作码。<br>例如现在有两条指令，一条是四地址指令，一条是三地址指令，下面是他们二进制数据的展示情况（为了把更多精力放在操作码上，地址码用 xxx 来表示）：</p>
<p><img src="https://s2.loli.net/2022/01/07/O7QdwhIEz4ibgq8.png" alt="image-20220107125708122"></p>
<p>看到上图的时候是不是还没察觉到问题？那么我们将图简化一下：</p>
<p><img src="https://s2.loli.net/2022/01/07/AXLxmhVb4iF1nM5.png" alt="image-20220107125837964"></p>
<p>看出来了吗？就是你无法分清这两条指令那条是三地址指令哪条是四地址指令。所以有了一个规定，短码不能是长码的前缀。<br>这个时候一般会预留出一个拓展窗口，例如减少一条四地址指令，让 1111 作为拓展窗口，让四地址指令的操作码最多取到 1110，这时如果你看到操作码是前四位是 1111 你就知道这个肯定不是四地址指令了，当然其他数量的地址指令通过类似的操作也可以解决这个问题，值得注意的是，拓展窗口不一定是一个，也可以是多个。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>网站典型故障案例</title>
    <url>/posts/269fd615.html</url>
    <content><![CDATA[<h2 id="1-写日志也会引发故障"><a href="#1-写日志也会引发故障" class="headerlink" title="1.写日志也会引发故障"></a>1.写日志也会引发故障</h2><h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><p>某应用服务器在项目发布后不久就出现报警，硬盘可用空间低于警戒值，并且很快就宕机。登录到线上服务器，发现log文件夹里的文件迅速增加，不断消耗磁盘空间。</p>
<span id="more"></span>

<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>部署完系统后硬盘还剩余几十个G，正常情况下这些磁盘空间足够了，但是该应用的开发人员将l o g输出的level全局配置为Debug。这样一次简单的Web请求就会产生大量的log文件输出，在高并发的用户请求下，很快就消耗完不多的磁盘空间</p>
<h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>应用程序自己的日志输出配置和第三方组件日志输出要分别配置。<br>检查log配置文件，日志输出级别至少为Warn，并且检查log输出代码调用，调用级别要符合其真实日志级别。<br>有些开源的第三方组件也会不恰当地输出太多的Error日志，需要关闭这些第三方库的日志输出，至于哪些第三方库有问题，只有在遇到问题时才知道。</p>
<h2 id="2-高并发访问数据库引发的故障"><a href="#2-高并发访问数据库引发的故障" class="headerlink" title="2.高并发访问数据库引发的故障"></a>2.高并发访问数据库引发的故障</h2><h3 id="故障现象-1"><a href="#故障现象-1" class="headerlink" title="故障现象"></a>故障现象</h3><p>某应用发布后，数据库Load居高不下，远超过正常水平，持续报警。</p>
<h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>查数据库，发现报警是因为某条SQL引起的，这条SQL是一条简单的有索引的数据查询，不应该引发报警。继续检查，发现这条SQL执行频率非常高，远远超过正常水平。追查这条SQL，发现被网站首页应用调用，首页是被访问最频繁的网页，这条SQL被首页调用，也就被频繁执行了。</p>
<h3 id="经验教训-1"><a href="#经验教训-1" class="headerlink" title="经验教训"></a>经验教训</h3><p>首页不应该访问数据库，首页需要的数据可以从缓存服务器或者搜索引擎服务器获取。<br>首页最好是静态的。</p>
<h2 id="3-高并发情况下锁引发的故障"><a href="#3-高并发情况下锁引发的故障" class="headerlink" title="3.高并发情况下锁引发的故障"></a>3.高并发情况下锁引发的故障</h2><h3 id="故障现象-2"><a href="#故障现象-2" class="headerlink" title="故障现象"></a>故障现象</h3><p>某应用服务器不定时地因为响应超时而报警，但是很快又超时解除，恢复正常，如此反复，让运维人员非常苦恼。</p>
<h3 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h3><p>程序中某个单例对象（singleton object）中多处使用了synchronized（this），由于this对象只有一个，所有的并发请求都要排队获得这唯一的一把锁。一般情况下，都是一些简单操作，获得锁，迅速完成操作，释放锁，不会引起线程排队。但是某个需要远程调用的操作也被加了synchronized（this），这个操作只是偶尔会被执行，但是每次执行都需要较长的时间才能完成，这段时间锁被占用，所有的用户线程都要等待，响应超时，这个操作执行完后释放锁，其他线程迅速执行，超时解除。</p>
<h3 id="经验教训-2"><a href="#经验教训-2" class="headerlink" title="经验教训"></a>经验教训</h3><p>使用锁操作要谨慎</p>
<h2 id="4-缓存引发的故障"><a href="#4-缓存引发的故障" class="headerlink" title="4.缓存引发的故障"></a>4.缓存引发的故障</h2><h3 id="故障现象-3"><a href="#故障现象-3" class="headerlink" title="故障现象"></a>故障现象</h3><p>没有新应用发布，但是数据库服务器突然Load飙升，并很快失去响应。DBA将数据库访问切换到备机，Load也很快飙升，并失去响应。最终引发网站全部瘫痪</p>
<h3 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h3><p>缓存服务器在网站服务器集群中的地位一直比较低，服务器配置和管理级别都比其他服务器要低一些。人们都认为缓存是改善性能的手段，丢失一些缓存也没什么问题，有时候关闭一两台缓存服务器也确实对应用没有明显影响，所以长期疏于管理缓存服务器。结果这次一个缺乏经验的工程师关闭了缓存服务器集群中全部的十几台Memcached服务器，导致了网站全部瘫痪的重大事故</p>
<h3 id="经验教训-3"><a href="#经验教训-3" class="headerlink" title="经验教训"></a>经验教训</h3><p>当缓存已经不仅仅是改善性能，而是成为网站架构不可或缺的一部分时，对缓存的管理就需要提高到和其他服务器一样的级别</p>
<h2 id="5-大文件读写独占磁盘引发的故障"><a href="#5-大文件读写独占磁盘引发的故障" class="headerlink" title="5.大文件读写独占磁盘引发的故障"></a>5.大文件读写独占磁盘引发的故障</h2><h3 id="故障现象-4"><a href="#故障现象-4" class="headerlink" title="故障现象"></a>故障现象</h3><p>某应用主要功能是管理用户图片，接到部分用户投诉，表示上传图片非常慢，原来只需要一两秒，现在需要几十秒，有时等半天结果浏览器显示服务器超时</p>
<h3 id="原因分析-4"><a href="#原因分析-4" class="headerlink" title="原因分析"></a>原因分析</h3><p>图片需要使用存储，最有可能出错的地方是存储服务器。检查存储服务器，发现大部分文件只有几百KB，而有几个文件非常大，有数百兆，读写这些大文件一次需要几十秒，这段时间，磁盘基本被这个文件操作独占，导致其他用户的文件操作缓慢。</p>
<h3 id="经验教训-4"><a href="#经验教训-4" class="headerlink" title="经验教训"></a>经验教训</h3><p>存储的使用需要根据不同文件类型和用途进行管理，图片都是小文件，应该使用专用的存储服务器，不能和大文件共用存储。批处理用的大文件可以使用其他类型的分布式文件系统。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>网站架构模式</title>
    <url>/posts/15dd4f.html</url>
    <content><![CDATA[<p>大型互联网公司为了实现网站的高性能、高可用、易伸缩、可扩展、安全等各种技术架构目标，提出了很多解决方案，而这些方案又被更多网站重复使用，从而逐渐形成大型网站架构模式，下面对常见的模式进行总结。</p>
<span id="more"></span>

<h2 id="1、分层"><a href="#1、分层" class="headerlink" title="1、分层"></a>1、分层</h2><p>分层是企业应用系统中最常见的一种架构模式，将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统，一般会将网站软件系统分为应用层、服务层、数据层</p>
<h3 id="优点：便于分工合作开发和维护"><a href="#优点：便于分工合作开发和维护" class="headerlink" title="优点：便于分工合作开发和维护"></a>优点：便于分工合作开发和维护</h3><p>因为各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体问题独立演化发展而不需要其他层必须做出相应调整。</p>
<h3 id="缺点：加大了设计系统的难度"><a href="#缺点：加大了设计系统的难度" class="headerlink" title="缺点：加大了设计系统的难度"></a>缺点：加大了设计系统的难度</h3><p>必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或者服务层调用应用层）。</p>
<h2 id="2、分割"><a href="#2、分割" class="headerlink" title="2、分割"></a>2、分割</h2><p>分割是在纵向方面对软件进行切分，将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，例如将购物、论坛、搜索、广告分割成不同的应用，由独立的团队负责，部署在不同的服务器上</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>1、有助于软件的开发和维护</li>
<li>2、便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力</li>
</ul>
<h2 id="3、分布式"><a href="#3、分布式" class="headerlink" title="3、分布式"></a>3、分布式</h2><p>分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作。</p>
<h3 id="优点：可以为更多的用户提供服务"><a href="#优点：可以为更多的用户提供服务" class="headerlink" title="优点：可以为更多的用户提供服务"></a>优点：可以为更多的用户提供服务</h3><p>分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>1、性能可能会收到较大影响</p>
<p>因为分布式服务之间的调用必须通过网络</p>
</li>
<li><p>2、可用性可能会降低</p>
<p>服务器越多，服务器宕机的概率也就越大，一台服务器宕机造成的服务不可用可能会导致很多应用不可访问</p>
</li>
<li><p>3、难以保持数据的一致性</p>
</li>
<li><p>4、开发管理维护难度加大</p>
</li>
</ul>
<h3 id="常用的分布式方案："><a href="#常用的分布式方案：" class="headerlink" title="常用的分布式方案："></a>常用的分布式方案：</h3><ul>
<li><p>1、分布式应用和服务</p>
<p>将分层和分割后的应用和服务模块分布式部署</p>
<ul>
<li><p>优点：</p>
<ul>
<li>1、改善网站性能和并发性、加快开发和发布速度、减少数据库连接资源消耗外</li>
<li>2、可以使不同应用复用共同的服务，便于业务功能扩展</li>
</ul>
</li>
</ul>
</li>
<li><p>2、分布式静态资源</p>
<p>也叫动静分离，网站的静态资源如JS，CSS，Logo图片等资源独立分布式部署，并采用独立的域名</p>
<ul>
<li><p>优点：</p>
<ul>
<li>1、静态资源分布式部署可以减轻应用服务器的负载压力</li>
<li>2、通过使用独立域名加快浏览器并发加载的速度</li>
<li>3、由负责用户体验的团队进行开发维护有利于网站分工合作，使不同技术工种术业有专攻</li>
</ul>
</li>
</ul>
</li>
<li><p>3、分布式数据和存储</p>
<p>大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据需要分布式存储</p>
</li>
</ul>
<h2 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h2><p>即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p>1、更好的并发性</p>
<p>因为有很多服务器提供相同的服务</p>
</li>
<li><p>2、更好的拓展性</p>
<p>如果目前的资源不能满足业务需求可以直接以增加服务器的方式对系统进行拓展</p>
</li>
<li><p>3、更好的可用性</p>
<p>如果某台服务器宕机并不会对系统功能造成影响，因为负载均衡设备会将请求转发到其他服务器中</p>
</li>
</ul>
<h2 id="5、缓存"><a href="#5、缓存" class="headerlink" title="5、缓存"></a>5、缓存</h2><p>缓存就是将数据存放在距离计算最近的位置以加快处理速度。<br>使用缓存前提条件：<br>1、数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；2、数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。</p>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>1、加快数据访问速度</li>
<li>2、减轻后端应用和数据存储的负载压力</li>
</ul>
<h3 id="常用缓存方式："><a href="#常用缓存方式：" class="headerlink" title="常用缓存方式："></a>常用缓存方式：</h3><ul>
<li><p>1、CDN</p>
<p>容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源（较少变化的数据），可以就近以最快速度返回给用户，如视频网站和门户网站会将用户访问量大的热点内容缓存在CDN。</p>
</li>
<li><p>2、反向代理</p>
<p>反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问到的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。</p>
</li>
<li><p>3、本地缓存</p>
<p>在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无需访问数据库，例如使用redis进行缓存</p>
</li>
<li><p>4、分布式缓存</p>
<p>大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据</p>
</li>
</ul>
<h2 id="6、异步"><a href="#6、异步" class="headerlink" title="6、异步"></a>6、异步</h2><p>主要目的是解耦，将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作。<br>单一服务器内部可通过多线程共享内存队列的方式实现异步；<br>在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署。</p>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p>1、提高系统可用性</p>
<p>消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正常后，继续处理消息队列中的数据。</p>
</li>
<li><p>2、加快网站响应速度</p>
<p>处在业务处理前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少。</p>
</li>
<li><p>3、消除并发访问高峰</p>
<p>用户访问量有可能突然增加很多倍，但是并不会持续很久，例如在秒杀活动进行的时刻，这种突增的访问量有可能是服务被压垮，如果为了这个时刻而增加硬件设施又得不偿失，所以使用异步的方式就可以做到“削峰填谷”，使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。</p>
</li>
</ul>
<h2 id="7、冗余"><a href="#7、冗余" class="headerlink" title="7、冗余"></a>7、冗余</h2><p>沉余包括服务器冗余运行，数据冗余备份。网站需要不间断的提供服务，因此必须保证在有服务器宕机的情况下可以将服务和数据转移到其他机器上，以保证服务的高可用和数据的不丢失</p>
<h2 id="8、自动化"><a href="#8、自动化" class="headerlink" title="8、自动化"></a>8、自动化</h2><p>包括但不限于以下部分：<br>1、自动化代码管理；2、自动化测试；3、自动化安全检测；4、自动化部署；<br>5、自动化监控 等等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>网站的高性能架构</title>
    <url>/posts/7b9932ab.html</url>
    <content><![CDATA[<p>网站性能是客观的指标，可以具体体现到响应时间、吞吐量等技术指标，同时也是主观的感受，而感受则是一种与具体参与者相关的微妙的东西，用户的感受和工程师的感受不同，不同的用户感受也不同。</p>
<span id="more"></span>

<h2 id="1-网站性能测试"><a href="#1-网站性能测试" class="headerlink" title="1. 网站性能测试"></a>1. 网站性能测试</h2><p>性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。不同视角下的网站性能有不同的标准，也有不同的优化手段。</p>
<h3 id="1-1不同视角下的网站性能"><a href="#1-1不同视角下的网站性能" class="headerlink" title="1.1不同视角下的网站性能"></a>1.1不同视角下的网站性能</h3><ul>
<li><p>1.1.1 用户视角的网站性能</p>
<p>从用户角度，网站性能就是用户在浏览器上直观感受到的网站响应速度快还是慢</p>
<ul>
<li><p>优化手段：</p>
<p>使用一些前端架构优化手段，通过优化页面HTML式样、利用浏览器端的并发和异步特性、调整浏览器缓存策略、使用CDN服务、反向代理等手段，使浏览器尽快地显示用户感兴趣的内容、尽可能近地获取页面内容，即使不优化应用程序和架构，也可以很大程度地改善用户视角下的网站性能</p>
</li>
</ul>
</li>
<li><p>1.1.2 开发人员视角的网站性能</p>
<p>开发人员关注的主要是应用程序本身及其相关子系统的性能，包括响应延迟、系统吞吐量、并发处理能力、系统稳定性等技术指标。</p>
<ul>
<li><p>优化手段：</p>
<p>使用缓存加速数据读取，使用集群提高吞吐能力，使用异步消息加快请求响应及实现削峰，使用代码优化手段改善程序性能。</p>
</li>
</ul>
</li>
<li><p>1.1.3 运维人员视角的网站性能</p>
<p>运维人员更关注基础设施性能和资源利用率，如网络运营商的带宽能力、服务器硬件的配置、数据中心网络架构、服务器和网络带宽的资源利用率等</p>
<ul>
<li><p>优化手段</p>
<p>建设优化骨干网、使用高性价比定制服务器、利用虚拟化技术优化资源利用等</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-性能测试指标"><a href="#1-2-性能测试指标" class="headerlink" title="1.2 性能测试指标"></a>1.2 性能测试指标</h3><p>不同视角下有不同的性能标准，不同的标准有不同的性能测试指标，从开发和测试人员的视角，网站性能测试的主要指标有响应时间、并发数、吞吐量、性能计数器等</p>
<ul>
<li><p>1.2.1 响应时间</p>
<p>指应用执行一个操作需要的时间，包括从发出请求开始到收到最后响应数据所需要的时间</p>
</li>
<li><p>1.2.2 并发数</p>
<p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。</p>
</li>
<li><p>1.2.3 吞吐量</p>
<p>单位时间内系统处理的请求数量，体现系统的整体处理能力</p>
</li>
<li><p>1.2.4 性能计数器</p>
<p>它是描述服务器或操作系统性能的一些数据指标。包括SystemLoad、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标。这些指标也是系统监控的重要参数，对这些指标设置报警阈值，当监控系统发现性能计数器超过阈值时，就向运维和开发人员报警，及时发现处理系统异常。</p>
</li>
</ul>
<h3 id="1-3-性能测试方法"><a href="#1-3-性能测试方法" class="headerlink" title="1.3 性能测试方法"></a>1.3 性能测试方法</h3><p>性能测试是一个总称，具体可细分为性能测试、负载测试、压力测试、稳定性测试。</p>
<h2 id="2-Web前端性能优化"><a href="#2-Web前端性能优化" class="headerlink" title="2. Web前端性能优化"></a>2. Web前端性能优化</h2><h3 id="2-1-浏览器访问优化"><a href="#2-1-浏览器访问优化" class="headerlink" title="2.1 浏览器访问优化"></a>2.1 浏览器访问优化</h3><ul>
<li><p>2.1.1 减少http请求</p>
<ul>
<li><p>2.1.1.1 为什么</p>
<p>HTTP协议是无状态的应用层协议，意味着每次HTTP请求都需要建立通信链路、进行数据传输，而在服务器端，每个HTTP都需要启动独立的线程去处理</p>
</li>
<li><p>2.1.1.2 怎么办</p>
<p>合并CSS、合并JavaScript、合并图片，这样一次请求就可以获取多个需要的文件</p>
</li>
</ul>
</li>
<li><p>2.1.2 使用浏览器缓存</p>
<p>将更新的频率都低，而访问平凡的文件缓存在浏览器中，可以极好地改善性能</p>
</li>
<li><p>2.1.3 启用压缩</p>
<p>在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。有利就有弊，压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。</p>
</li>
<li><p>2.1.4 CSS放在页面最上面、JavaScript放在页面最下面</p>
<p>浏览器会在下载完全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。JavaScript则相反，浏览器在加载JavaScript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此JavaScript最好放在页面最下面。</p>
</li>
<li><p>2.1.5 减少Cookie传输</p>
<p>Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输</p>
</li>
<li><p>2.1.5 CDN加速</p>
<p>CDN（Content Distribute Network，内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据</p>
</li>
<li><p>2.1.6 反向代理</p>
<p>1、可以缓存静态内容，加快web访问；<br>2、保护网站安全，相当于在Web服务器和可能的网络攻击之间建立了一个屏障。</p>
</li>
</ul>
<h2 id="3-应用服务器性能优化"><a href="#3-应用服务器性能优化" class="headerlink" title="3. 应用服务器性能优化"></a>3. 应用服务器性能优化</h2><p>优化手段主要有缓存、集群、异步等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <url>/posts/4cd43d51.html</url>
    <content><![CDATA[<p>虚拟机字节码执行引擎是java虚拟机核心组成部分之一，所有java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<span id="more"></span>

<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>java虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，栈帧需要分配多少内存编译期已经确定，并不会收到程序运行期变量数据的影响；以java程序的角度来看，同一时刻、同一线程里面，在调用堆栈的所有方法都同时处于执行状态，但在活动线程中，只有位于栈顶的方法才是在运行的，被称为当前栈帧，执行引擎所运行的字节码执行都只针对当前栈帧进行操作。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>是一组变量值的存储空间，属于线程私有，用于存放方法参数和方法内部定义的局部变量，在java程序被编译为class文件时就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量，它以变量槽为最小单位，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化</p>
<ul>
<li><p>工作机制</p>
<ul>
<li>当一个方法被调用时，java虚拟机会使用局部变量表来完成参数值到参数变量的传递过程，即实参到形参的传递。如果执行的是实例方法，那局部变量表的第0位索引的变量槽默认是用于传递方法所属对象实例的引用，可以用this表示，其余参数按照顺序排列，而且局部变量表是可以重用的</li>
</ul>
</li>
</ul>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>常被称为操作栈，是一个后入先出栈，它的最大深度在编译的时候已经确定</p>
<ul>
<li><p>工作机制</p>
<ul>
<li>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法的执行过程中会有各种字节码执行往操作数栈中写入和提取内容（入栈出栈的元素是局部变量表中的局部变量）</li>
</ul>
</li>
</ul>
<h3 id="栈帧信息"><a href="#栈帧信息" class="headerlink" title="栈帧信息"></a>栈帧信息</h3><ul>
<li><p>动态链接</p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个过程是为了支持方法调用过程中的动态连接（就是将符号引用转为直接引用）</p>
</li>
<li><p>方法返回地址</p>
<p>方法退出之后都必须返回到最初方法被调用时的位置</p>
</li>
<li><p>附加信息</p>
<p>可以返回一些java虚拟机没有描述的信息</p>
</li>
</ul>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将一部分符号引用转化为直接引用，前提是方法在程序真正运行之前就有一个可确定的调用版本，并且在运行期不可改变，这类方法的调用被称为解析；符合“编译期可知，运行期不可变”要求的方法主要静包括态方法和私有方法，这两类都不可能重写出其他版本</p>
<ul>
<li><p>非虚方法</p>
<p>私有方法、实例构造器、静态方法、父类方法，被final修饰的方法 这5中方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”</p>
<ul>
<li><p>解析调用</p>
<ul>
<li>是个静态过程，在编译期就完全确定，在类加载阶段就会将符号引用转变为直接引用</li>
</ul>
</li>
<li><p>分派调用</p>
<ul>
<li><p>静态分派</p>
<ul>
<li>主要表现为重载，虚拟机在重载时是通过参数的静态类型而不是实际类型作为判定依据的</li>
</ul>
</li>
<li><p>动态分派</p>
<ul>
<li>主要表现为重写，在运行期间根据实际类型确定方法执行版本的分派过程叫做动态分派</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><p>类型检查的主体过程是在运行期而不是编译期进行的</p>
<h3 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h3><p>主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路外提供一种新的动态确定目标方法的机制，称为方法句柄</p>
<ul>
<li><p>方法句柄和反射的区别</p>
<ul>
<li>1、反射是在模拟java代码层次的方法调用，方法句柄是在模拟字节码层次的方法调用</li>
<li>2、反射是重量级的，方法句柄是轻量级的</li>
<li>3、方法句柄可以享受虚拟机的优化策略，因为它是模拟字节码层面的方法调用</li>
</ul>
</li>
</ul>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>主要功能是配合虚拟机执行方法里面的字节码指令的</p>
<h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>java现在已经不能单纯归类于解释执行或者是编译执行，因为两者都有</p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>javac编译器输出的字节码指令流是一种基于栈的指令集架构</p>
<ul>
<li>栈：优点： 1、可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的受硬件的约束；2、代码相对更紧凑、编译器实现更加简单。缺点：1、理论上执行速度相对慢一些</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>集群环境下如何管理Session</title>
    <url>/posts/56231c3b.html</url>
    <content><![CDATA[<h2 id="1-Session复制"><a href="#1-Session复制" class="headerlink" title="1.Session复制"></a>1.Session复制</h2><p>应用服务器开启Web容器的Session复制功能，在集群中的几台服务器之间同步Session对象，使得每台服务器上都保存所有用户的Session信息，这样任何一台机器宕机都不会导致Session数据的丢失，而服务器使用Session时，也只需要在本机获取即可</p>
<span id="more"></span>

<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>1.方案简单</li>
<li>2.获取Session速度块</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>1.只能在集群规模较小的情况下使用</p>
<p>如果集群规模大，会导致大量复制Session，会占用网络和服务器大量资源；<br>并且如果出现大量用户同时访问服务的情况可能会出现内存不够用的问题</p>
</li>
</ul>
<h2 id="2-Session绑定"><a href="#2-Session绑定" class="headerlink" title="2.Session绑定"></a>2.Session绑定</h2><p>即Session绑定在某台特定服务器上，保证Session总能在这台服务器上获取。这种方法又被称作会话黏滞，负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上（也可以根据Cookie信息将同一个用户的请求总是分发到同一台服务器上，当然这时负载均衡服务器必须工作在HTTP协议层上）</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>不具备高可用的特性</p>
<p>如果绑定Session的服务器宕机了就会造成Session丢失</p>
</li>
</ul>
<h2 id="3-利用Cookie记录Session"><a href="#3-利用Cookie记录Session" class="headerlink" title="3.利用Cookie记录Session"></a>3.利用Cookie记录Session</h2><p>将Session记录在Cookie中，每次请求服务器的时候，将Session放在请求中发送给服务器，服务器处理完请求后再将修改过的Session响应给客户端。</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>简单易用，可用性高，支持应用服务器的线性伸缩</li>
</ul>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>1.信息记录有限，因为Cookie有大小限制</li>
<li>2.影响性能，每次请求响应都需要传输Cookie</li>
<li>3.受用户行为影响，如果用户关闭Cookie，访问就会不正常</li>
</ul>
<h2 id="4-Session服务器"><a href="#4-Session服务器" class="headerlink" title="4.Session服务器"></a>4.Session服务器</h2><p>可用性高、伸缩性好、性能也不错，对信息大小又没有限制的服务器集群Session管理方案。<br>利用独立部署的Session服务器（集群）统一管理Session，应用服务器每次读写Session时，都访问Session服务器。<br>这种解决方案事实上是将应用服务器的状态分离。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>项目如何分包</title>
    <url>/posts/772be079.html</url>
    <content><![CDATA[<p>在做项目的时候我经常思考如何分包更合理，按照目前常规的分包方式，大致可以分为以下几类：controller层、service层、dao层以及各种 helper、utils 等等，但是仅仅这样的分包方式并不能达到高内聚低耦合的目标，经常将一个完整的功能拆的稀碎，想要了解一个完整的功能要多次跳转，成本较高。所以我根据工作经验总结了下项目如何分包更合理。</p>
<span id="more"></span>

<h2 id="1、按照类型方式划分"><a href="#1、按照类型方式划分" class="headerlink" title="1、按照类型方式划分"></a>1、按照类型方式划分</h2><p>例如将所有的接口放入一个包、Controller类放入一个包等等。</p>
<p>优点：从类型看更为清晰</p>
<p>缺点：不利于模块化开发，因为会将同一个功能的多个类分散在不同的包中</p>
<h2 id="2、按照功能方式划分"><a href="#2、按照功能方式划分" class="headerlink" title="2、按照功能方式划分"></a>2、按照功能方式划分</h2><p>将同一个功能的所有类放在同一个包中。</p>
<p>优点：高内聚，便于模块化开发</p>
<p>缺点：同一包内类型混乱</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>将功能耦合度高的类按照功能进行划分，而功能耦合度低的或者供多个功能使用的类按照类型进行划分。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载机制</title>
    <url>/posts/cdffca23.html</url>
    <content><![CDATA[<p>java虚拟机把描述类的数据从Class文件加载到内存，并堆数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制</p>
<span id="more"></span>

<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类型从被加载到虚拟机内存中开始到卸载出内存为止的生命周期为：加载、验证、准备、解析、初始化、使用、卸载 总共七个阶段，其中验证、准备、解析三个部分统称为链接；加载、验证、准备、初始化和卸载是按照顺序执行的，而解析为了满足java动态绑定的需求可能会在初始化之后进行。</p>
<h3 id="必须立即对类初始化的六种情况"><a href="#必须立即对类初始化的六种情况" class="headerlink" title="必须立即对类初始化的六种情况"></a>必须立即对类初始化的六种情况</h3><p>虚拟机会为类和接口生成<clinit>()类构造器，用于初始化接口中所定义的成员变量；当一个类初始化时要求其全部父类都已经初始化过，而接口初始化时只有真正使用到父接口时才会初始化</p>
<ul>
<li>1、遇到new、getstatic（读取静态字段）、putstatic（设置静态字段）或invokestatic（调用静态方法）这四条字节码指令时。</li>
<li>2、使用java.lang.reflect包的方法对类型进行反射调用的时候</li>
<li>3、当初始化类时，要先初始化其父类</li>
<li>4、当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li>
<li>5、当使用jdk7加入的动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄时</li>
<li>6、当一个接口定义了JDK8新加入的默认方法时</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>开发人员可控性最强的阶段，主要表现在可以控制类二进制流的获取。数组是通过jvm自己创建的 再由类加载器创建数据中的元素类</p>
<ul>
<li><p>1、通过一个类的全限定名获取此类的二进制字节流</p>
<p>虚拟机并没有规定怎样获取二进制字节流，可以从网络、加密文件、压缩包等等不同方式获取</p>
</li>
<li><p>2、将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构</p>
</li>
<li><p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合java虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</p>
<ul>
<li><p>文件格式验证</p>
<p>验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理，只有通过了之后这段字节流才被允许进入java虚拟机内存的方法区中进行存储</p>
<ul>
<li>1、是否以魔数0XCAFEBABE开头</li>
<li>2、主、次版本号是否在当前java虚拟机接受范围之内</li>
<li>3、常量池的常量中是否有不被支持的常量类型</li>
<li>4、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>5、CONSTANT_Uft8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>6、Class文件中各个部分及文件本省是否有被删除的或附加的其他信息</li>
<li>。。。等等</li>
</ul>
</li>
<li><p>元数据验证</p>
<p>对字节码描述的信息进行语义分析，保证其描述的信息符合java语言规范的要求</p>
<ul>
<li>1、这个类是否有父类（除了java.lang.Object以外的类都有父类）</li>
<li>2、这个类的父类是否继承了不允许被继承的类（final修饰的类）</li>
<li>3、如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法</li>
<li>4、类中的字段、方法是否与父类产生矛盾</li>
<li>。。。等等</li>
</ul>
</li>
<li><p>字节码验证</p>
<p>主要目的是通过数据流分析和控制流分析确定程序语义是合法的符合逻辑的。</p>
<ul>
<li>1、保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>
<li>2、保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>3、保证方法体中的类型转换总是有效的</li>
<li>。。。等等</li>
</ul>
</li>
<li><p>符号引用验证</p>
<p>该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</p>
<ul>
<li>1、符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>2、在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>3、符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>
<li>。。。等等</li>
</ul>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段；jdk7以上的版本中 类变量随着Class对象一起存放在java堆中；此阶段实例变量不会分配内存，它会在对象实例化时随着对象一起分配在java堆中；此阶段会为类变量赋予系统要求的初始零值</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是java虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</p>
<ul>
<li><p>符号引用</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
</li>
<li><p>直接引用</p>
<p>直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
</li>
<li><p>1、类或接口的解析</p>
<p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或者接口C的直接引用，需要三步</p>
<ul>
<li>1.1 如果C不是数组，虚拟机将用D类的类加载器加载N</li>
<li>1.2 如果C是数组并且数组元素类型为对象，就按照1.1的规则加载元素类型 然后由虚拟机生成一个代表该数组维度和元素的数组对象</li>
<li>1.3 进行符号引用验证 确认D是否具备C的访问权限</li>
</ul>
</li>
<li><p>2、字段解析</p>
<p>要确保java虚拟机获得字段唯一的解析结果</p>
<ul>
<li>2.1 首先解析字段所属类或接口，用变量C表示</li>
<li>2.2 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束</li>
<li>2.3 如果C中实现了接口，将按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到相匹配的字段则返回字段的直接引用，查找结束</li>
<li>2.4 如果C不是java.lang.Object 将会按照继承关系从下往上递归搜索其父类，如果在父类中找到相匹配的字段则返回字段的直接引用 查找结束</li>
<li>2.5 如果还没找到则抛出 java.lang.NoSuchFieldError异常 查找失败</li>
<li>2.6 如果查找成功就对字段进行权限验证</li>
</ul>
</li>
<li><p>3、类的方法解析</p>
<ul>
<li>3.1 首先解析字段所属类或接口，用变量C表示</li>
<li>3.2  检查C是否为类 如果发现C是个接口就直接抛出异常</li>
<li>3.3 在C中找到相匹配的方法返回方法的直接引用，查找结束</li>
<li>3.4 在C的父类中递归查找 如果有相匹配的方法返回方法的直接引用，查找结束</li>
<li>3.5 在C的实现接口列表中查找，如果存在相匹配的方法说明C是一个抽象类，抛出AbstractMethodError异常 查找结束</li>
<li>3.6 否则查找失败 抛出NoSuchMethodError异常</li>
<li>3.7 如果查找成功则进行权限校验</li>
</ul>
</li>
<li><p>4、接口方法解析</p>
<ul>
<li>与类方法解析相似</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这个是类加载的最后一个步骤，会根据程序员的主管计划去初始化类变量和其他资源；</p>
<ul>
<li><p><clinit>()</p>
<p>初始化也可以说是执行类构造器<clinit>()方法的过程，</p>
<ul>
<li><clinit>()是编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的</li>
<li>不需要显示的调用父类构造器，java虚拟机保证父类的<clinit>() 先执行，意味着父类的静态语句赋值操作要优先于子类先执行</li>
<li>这个方法不是必须的，如果一个类中没有静态代码块，也没有类变量的赋值操作那么也可以不生成此方法</li>
<li>接口中执行此方法不需要先执行父接口的<clinit>()方法 只有父接口中定义的变量被使用时父接口才会初始化</li>
<li>接口实现类初始化时也不会执行接口<clinit>()方法</li>
<li>Java虚拟机必须保证一个类的<clinit>()是线程安全的</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器定义：通过一个类的全限定名来获取描述该类的二进制字节流的代码</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>任意一个类都必须由加载它的类加载器和这个类本身一起共同确定其在java虚拟机总的唯一性</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>只存在两种不同的类加载器，一种是启动类加载器，这个类加载器使用C++语言实现，是虚拟机的一部分；另一个种是其他所有类的加载器，这些类加载器都由java语言实现，独立存在于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader； 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类，父子关系通常是使用组合关系来复用父加载器的代码</p>
<ul>
<li><p>类加载器分类</p>
<ul>
<li><p>启动类加载器</p>
<p>启动类加载器无法被java程序直接引用</p>
<ul>
<li>负责加载存放在<JAVA_HOME>\lib目录或者被 -Xboostclasspath参数所指定的路径中存放的而且是java虚拟机能够识别的类库加载到虚拟机的内存中</li>
</ul>
</li>
<li><p>扩展类加载器</p>
<ul>
<li>在sum.misc.Launcher$ExtClassLoader中以java代码形式实现的 负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库</li>
</ul>
</li>
<li><p>应用程序类加载器</p>
<ul>
<li>在sum.misc.Launcher$AppClassLoader中以java代码形式实现的，负责加载用户类路径上所有的类库，一般情况下这个就是程序中默认的类加载器</li>
</ul>
</li>
</ul>
</li>
<li><p>工作过程</p>
<ul>
<li>如果一个类加载器要加载一个类，首先把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，只有当父加载器反馈自己无法完成这个加载请求时子加载器才会尝试去完成加载</li>
<li>优点：类会随着它的类加载器一起具备一种带有优先级的层次关系，避免核心类被篡改</li>
</ul>
</li>
<li><p>破坏双亲委派</p>
<ul>
<li>1、兼容以前的版本，双亲委派机制出现在jdk1.2之后才引入，但是java.lang.ClassLoader在第一个版本中就已经出现，所以为了兼容以前的代码必须做出妥协，在ClassLoader中增加findClass()方法并引导用户重写此方法</li>
<li>2、模型自身缺陷，基础类型无法回调用户的代码，也可以说父类加载器要加载子类加载器负责加载的类，解决方法是增加线程上下文类加载器，让用户可以设置要回调的子类加载器</li>
<li>3、满足用户对程序的动态性追求，指代码热替换、模块热部署等等，典型应用是OSGI</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch，CyclicBarrier，Semaphore及AQS介绍</title>
    <url>/posts/a33de4ce.html</url>
    <content><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>CountDownLatch适用于在多线程的场景需要等待所有子线程全部执行完毕之后再做操作的场景。</p>
<span id="more"></span>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.submit(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程执行任务 &quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟任务执行所用时间</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束运行&quot;</span>);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="new-CountDownLatch-5-发生了什么？"><a href="#new-CountDownLatch-5-发生了什么？" class="headerlink" title="new CountDownLatch(5) 发生了什么？"></a>new CountDownLatch(5) 发生了什么？</h4><p>通过构造函数可以看出，当我们执行new CountDownLatch(5)时会创建一个Sync对象，这个对象是CountDownLatch的一个内部类，Sync继承了AbstractQueuedSynchronizer抽象类，这个抽象类就是著名的AQS，java中很多重要的功能都有使用，关于AQS后续再详细介绍，先专注当前的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看下Sync的构造方法，可以看到会将我们传入的数字赋值给一个int 类型的属性state，到此CountDownLatch就创建完毕了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="当调用latch-await-时发生了什么？"><a href="#当调用latch-await-时发生了什么？" class="headerlink" title="当调用latch.await();时发生了什么？"></a>当调用latch.await();时发生了什么？</h4><p>当调用这个方法后当前线程会尝试获取执行权限（就是当state等于0的时候），如果获取不到执行权限就加入队列中，并在一个死循环中尝试获取执行权限。</p>
<p>await方法会调用sync.acquireSharedInterruptibly方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sync.acquireSharedInterruptibly 方法中会调用tryAcquireShared 方法检查当前state是否为0，如果不为0就会返回-1，会执行doAcquireSharedInterruptibly 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先调用addWaiter方法，将当前线程加入到队列中，然后在死循环中通过tryAcquireShared方法检查state是否为0，如果为0就跳出循环继续执行主线程的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果node的前一个节点是头节点就尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//如果r大于零说明成功获得锁</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="comment">//将node节点设置为头节点，并唤醒下一个阻塞的节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是头节点就阻塞，如果阻塞失败就抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面来看下addWaiter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//首先会利用当前线程创建一个node节点，</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//获取队列中最后一个节点 </span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果不为空就将node加入到队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//将当前队列最后一个节点的引用赋值到node的prev属性中</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//利用CAS获取临界区的执行权限，如果compareAndSetTail返回true说明当前没有其他线程在修改这个值，那么就将node的引用赋值到当前最后一个节点的next属性中</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>addWaiter方法最后还要执行enq方法，enq方法如果发现当前队列还没有初始化就会将node放在队列的头部，如果已经初始化了就将node放在队列末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="当调用latch-countDown-时发生了什么？"><a href="#当调用latch-countDown-时发生了什么？" class="headerlink" title="当调用latch.countDown();时发生了什么？"></a>当调用latch.countDown();时发生了什么？</h4><p>每次执行这个方法的时候都会将state的数字减一，直到state到0为止，如果state到0就会让所有阻塞的线程继续执行。</p>
<p>首先countDown会调用sync.releaseShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>releaseShared会调用tryReleaseShared方法将state减一，如果tryReleaseShared返回true，就会执行doReleaseShared方法，释放所有队列中阻塞的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面看下tryReleaseShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//获取当前state的值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//如果当前state的值已经为0就不执行减一操作，并返回false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//执行减一操作</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//利用CAS将nextc赋值给state</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="comment">//这里还要进行判断是因为可能有其他线程更改了这个值</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>node 状态介绍：</p>
<ol>
<li>int CANCELLED =  1;//waitStatus值为1时表示该线程节点已释放（超时、中断），已取消的节点不会再阻塞；</li>
<li>int SIGNAL    = -1;//waitStatus为-1时表示该线程的后续线程需要阻塞，即只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程 ；</li>
<li>int CONDITION = -2; //waitStatus为-2时，表示该线程在condition队列中阻塞（Condition有使用）；</li>
<li> int PROPAGATE = -3;//waitStatus为-3时，表示该线程以及后续线程进行无条件传播（CountDownLatch中有使用）共享模式下， PROPAGATE 状态的线程处于可运行状态 ；</li>
<li>值为0，表示当前节点在sync队列中，等待着获取锁<br>下面看doReleaseShared方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里用死循环是因为head节点可能会被其他线程更改掉</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//获取头部节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//如果队列不为空并且有多于一个以上的节点再执行if代码块中的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        	<span class="comment">//获取节点的状态信息</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">//如果状态为SIGNAL说明h节点后面的节点在阻塞，等待执行</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            </span><br><span class="line">                <span class="comment">//执行unparkSuccessor方法，唤醒后面节点所包含的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果状态为0就尝试将其状态更改为PROPAGATE</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断这个过程中头节点是否被更改过，如果更改过就再执行一遍循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
下面来看unparkSuccessor方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取节点状态信息</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//小于0就将状态设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//拿到下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    如果节点状态大于<span class="number">0</span>说明线程已经放弃争取锁，就设置为<span class="keyword">null</span>方便GC回收</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果头节点的下一个节点已经放弃执行，那就找到最接近头节点并且状态小于等于0的节点进行唤醒。</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-CountDownLatch总结"><a href="#1-3-4-CountDownLatch总结" class="headerlink" title="1.3.4 CountDownLatch总结"></a>1.3.4 CountDownLatch总结</h4>CountDownLatch在初始化的时候会设置一个任务总数并将数量赋值给state，latch.await();会让主线程加入到线程队列中，并一直通过CAS的方式检查state是否为0，而每当子线程执行latch.countDown();时就会利用CAS将state减一，直到减到0为止，这个时候主线程就获得了执行权限继续执行。</li>
</ol>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>CyclicBarrier叫做回环屏障，它的作用是让一组线程全部达到一个状态之后再全部同时执行，而且他有一个特点就是所有线程执行完毕之后是可以重用的。</p>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span></span><br><span class="line">                , () -&gt; System.out.println(<span class="string">&quot;所有成员都到达指定地点,开始吃饭&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始出发 &quot;</span> + Thread.currentThread());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;到达指定地点，等待下一步指令 &quot;</span> + Thread.currentThread());</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始吃饭 &quot;</span> + Thread.currentThread());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="new-CyclicBarrier-时发生了什么？"><a href="#new-CyclicBarrier-时发生了什么？" class="headerlink" title="new CyclicBarrier 时发生了什么？"></a>new CyclicBarrier 时发生了什么？</h4><p>会直接创建CyclicBarrier对象，可以接受两个参数，第一个是需要有多少个线程必须运行到指定状态后才能一起继续执行，第二个是当到达指定状态后的一个回调方法（可以省略）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当调用barrier-await-时发生了什么？"><a href="#当调用barrier-await-时发生了什么？" class="headerlink" title="当调用barrier.await();时发生了什么？"></a>当调用barrier.await();时发生了什么？</h4><p>barrier.await()最终会调用dowait方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">     <span class="comment">//先用重入锁进行加锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (g.broken)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">//如果线程中断过就直接放开所有线程，让他们继续执行</span></span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">             breakBarrier();</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//数量减一</span></span><br><span class="line">         <span class="keyword">int</span> index = --count;</span><br><span class="line">         <span class="comment">//如果为0说明所有线程到达指定状态</span></span><br><span class="line">         <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">             <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">             	<span class="comment">//判断是否有传回调方法如果有就执行</span></span><br><span class="line">                 <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                 <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                     command.run();</span><br><span class="line">                 ranAction = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="comment">//重制count数值，为下一次使用做准备，这就是为什么能够重用的原因</span></span><br><span class="line">                 nextGeneration();</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             	<span class="comment">//判断条件为true说明已经到达指定状态，放开所有阻塞的线程</span></span><br><span class="line">                 <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                     breakBarrier();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果没到0就阻塞线程</span></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">             	<span class="comment">//判断是否有设置超时时间，如果没有就直接await等待唤醒</span></span><br><span class="line">                 <span class="keyword">if</span> (!timed)</span><br><span class="line">                     trip.await();</span><br><span class="line">                 <span class="comment">//如果有设置超时时间就睡眠指定时间</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                     nanos = trip.awaitNanos(nanos);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                     breakBarrier();</span><br><span class="line">                     <span class="keyword">throw</span> ie;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (g.broken)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (g != generation)</span><br><span class="line">                 <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                 breakBarrier();</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     	<span class="comment">//解锁</span></span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看一下breakBarrier方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//会重新初始化count的值，这就是为什么可以复用</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//唤醒所有await的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CyclicBarrier-总结"><a href="#CyclicBarrier-总结" class="headerlink" title="CyclicBarrier 总结"></a>CyclicBarrier 总结</h3><p>CyclicBarrier比较简单，直接使用 Lock和Condition进行线程的协调工作.</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>常用于限制可以访问某些资源（物理或逻辑的）线程数目。</p>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (semaphore.availablePermits() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前令牌已经用完，请等待其他线程释放令牌&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在执行任务 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="源码解读-2"><a href="#源码解读-2" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="当new-Semaphore时发生了什么？"><a href="#当new-Semaphore时发生了什么？" class="headerlink" title="当new Semaphore时发生了什么？"></a>当new Semaphore时发生了什么？</h4><p>构造函数里面会创建NonfairSync对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NonfairSync对象继承自Sync对象，在CountDownLatch已经介绍过这个类了，那么很明显，Semaphore也是基于AQS实现的，到这里Semaphore就已经创建完毕了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当执行semaphore-acquire-时发生了什么？"><a href="#当执行semaphore-acquire-时发生了什么？" class="headerlink" title="当执行semaphore.acquire();时发生了什么？"></a>当执行semaphore.acquire();时发生了什么？</h4><p>当调用acquire方法时，会将AQS维护的state减一，可以理解为减少一个许可证，当state减少到0的时候剩余线程就会进入阻塞队列，直到有新的许可证可用（state不为0的时候）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="comment">//尝试获取许可证，当结果小于0的时候说明许可证用完了，就会执行doAcquireSharedInterruptibly方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面看下tryAcquireShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//获取许可证state的数量</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">//执行减一操作</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">//如果结果不小于0 就利用CAS进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面看下如果state小于零会发生什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//首先创建一个node节点并加入到列队尾部，addWaiter方法在上面已经讲过了，这里就不说了。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">//拿到当前节点的上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果为头节点就有资格尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            	<span class="comment">//尝试获取许可证</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//满足条件说明成功获得许可证</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="comment">//将此节点设置为头节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">//头节点的pre和next都被设置为Null，这样就让其脱离队列了</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果获取锁失败就将其阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	<span class="comment">//如果成功进入到这个代码块说明当前线程已经成功获取执行权限，就将Node节点从队列中删除</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="当执行semaphore-release-时发生了什么？"><a href="#当执行semaphore-release-时发生了什么？" class="headerlink" title="当执行semaphore.release()时发生了什么？"></a>当执行semaphore.release()时发生了什么？</h4><p>每次执行release方法时都会将state加一，然后唤醒队列中正在阻塞的线程。<br>release方法会调用releaseShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行state加一操作，如果成功就执行doReleaseShared方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryReleaseShared方法很简单，就是利用CAS将state加一而已。加一成功返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>doReleaseShared会唤醒队列头部的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    	<span class="comment">//获取队列头部的线程</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//判断队列至少有两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        	<span class="comment">//获取节点状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            	<span class="comment">//如果是SIGNAL状态，将状态设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            </span><br><span class="line">                <span class="comment">//设置成功后执行唤醒后一个Node节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止有其他线程更改头部节点，如果发现更改就再循环一次</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>unparkSuccessor方法会唤醒头部节点的下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取节点状态</span></span><br><span class="line">      <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">      <span class="comment">//如果是大于零的说明已经放弃争取锁了</span></span><br><span class="line">      <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">          compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果s节点正在阻塞等待被唤醒就执行if代码块中的逻辑</span></span><br><span class="line">      Node s = node.next;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          s = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//找到一个最接近头部节点可运行的节点进行唤醒，这里从队列后面开始找是为了防止多线程的环境下丢失节。</span></span><br><span class="line">          <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  s = t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      	<span class="comment">//唤醒节点</span></span><br><span class="line">          LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Semaphore总结"><a href="#Semaphore总结" class="headerlink" title="Semaphore总结"></a>Semaphore总结</h3><p>Semaphore初始化的时候会设置一个许可证的数量，每次执行semaphore.acquire();就会减一，如果state小于0就让其他线程阻塞，每次执行semaphore.release();都会将state加一并唤醒阻塞的线程，这样就可以控制同时执行的总任务数，可以用来限制资源的使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这三个功能都是基于AQS实现的，虽然CyclicBarrier是利用了Lock和Condition实现的但是其他内部实现也是利用AQS，如果你看懂了上面的逻辑其实就搞定AQS了，AQS会在全局维护一个state值和一个线程的队列，通过state值的数量来协调线程的运行和阻塞。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(二)</title>
    <url>/posts/93253ab9.html</url>
    <content><![CDATA[<h2 id="EntityManager-接口"><a href="#EntityManager-接口" class="headerlink" title="EntityManager 接口"></a>EntityManager 接口</h2><p>任何持久层框架都会提供一个管理持久层的 API。这个 API 一般都会提供基础的增删改查功能，通过它就可以管理持久化上下文。在 Java 持久层框架中，最常使用的接口就是 EntityManager。</p>
<span id="more"></span>

<h3 id="工作单元-unit-of-work-的权威解释"><a href="#工作单元-unit-of-work-的权威解释" class="headerlink" title="工作单元(unit of work)的权威解释"></a>工作单元(unit of work)的权威解释</h3><p>（ps: 单元可以理解为一种计量的单位，用来代表工作开始和结束这一过程。我阅读了整个小结，认为这段就是在讲什么是单元，单元其实就是类似事务，事务的开始代表工作开始，事务结束代表工作结束）。</p>
<p>在一些简单的 Java SE 和 Java EE 项目中 ( 例如只有一些 servlet )。你可以通过调用 EntityManagerFactory#createEntityManager() 方法获得一个 EntityManager 。你的应用代码共享 EntityManagerFactory ，这代表了一个持久层单元，或者一次操作数据库的逻辑（CRUD）。很多应用只会有一个EntityManagerFactory 被共享。</p>
<p>每个线程在操作数据库的时候都创建一个独有的  EntityManager 是很浪费资源的。下面来看下 <strong>工作单元</strong> 的经典代码：</p>
<p><img src="https://s2.loli.net/2021/12/14/awnmFQNg5YrObzG.png" alt="image-20211214131555083"></p>
<p>（ TM 类是这本书的工具类，通过它可以方便的使用  JNDI 的  UserTransactionAPI。图中 JPA 类为 共享的 UserTransactionAPI 提供了便捷的访问方式。）</p>
<p>一个事务中的所有操作都要在 tx.begin() 和 tx.commit() 之间进行。就目前而言，要记住在一个事务区间内的所有 CRUD 的操作，例如利用 Hibernate 执行 Sql 语句，要么全部成功，要么全部失败。现在不要太在意事务相关的代码；你将在下一个章节了解更多关于并发控制的知识。我们将会讲解一些关于事务和异常处理的代码。在发生异常的时候你需要回滚事务并且处理异常，所以 catch 代码块内不要空着。</p>
<p>创建一个 EntityManager 将开启它的持久化上下文。除非有必要不然 Hibernate 不会访问数据库；直到 Sql 必须执行的时候 </p>
<p>EntityManager 才会去获取 JDBC 连接。当你不需要操作数据库的时候可以关闭 EntityManager 。当你查找数据或者将持久化上下文中数据的更改同步到数据库中时才会执行 Sql 语句。当提交事务的时候 Hibernate 将对持久化上下文中的数据进行检查，并将更改同步到数据库中。当然，你也可以通过调用 EntityManager#flush() 方法在任意时间将更改强制同步到数据库中。</p>
<p>你可以通过调用 EntityManager#close() 方法决定持久化上下文的范围。通常你需要在 finally 中调用 close() 方法，避免内存泄漏。</p>
<h3 id="让数据持久化"><a href="#让数据持久化" class="headerlink" title="让数据持久化"></a>让数据持久化</h3><p>让我们创建一个新的 entity 实例，并让它从瞬时态转换成持久态。</p>
<p><img src="https://s2.loli.net/2021/12/14/FLsXMcJ8fIyiYg9.png" alt="image-20211214202340897"></p>
<p>你可以通过下图来看 Item 实例的状态是如何转变的。</p>
<p><img src="https://s2.loli.net/2021/12/14/oybeM6W1UdzDYQs.png" alt="image-20211214202634457"></p>
<p>一个新的瞬时态 Item 就是一个普通的实例。当然，你可能在创建 EntityManger 之前创建这个实例，然后你可以通过调用 persist() 方法让它转换成持久态。这时它将被当前持久化上下文管理。</p>
<p>Hibernate 通过执行 insert 语句来将 Item 实例存储到数据库中。当一个工作单元的事务提交了之后，Hibernate 会刷新持久化上下文，insert 就会在那时执行。Hibernate 甚至可以在 JDBC 层面批量执行 Insert 语句。当你调用 persist() 方法时，只有 Item 的 id 会被赋值。如果你的 ID 生成器没有提前为 ID 赋值，当你调用 persist() 的时候会立即执行 insert 语句。如果你忘记了这些知识可以回顾一下 4.2.5 节。</p>
<blockquote>
<p>小贴士：</p>
<p><strong>通过 ID 判断 entity 的状态</strong></p>
<p>有时你需要知道一个 entity 实例当前是什么状态。如果 EntityManager#contains(e) 返回 true 说明是持久态。如果 PersistenceUnitUtil#getIdentifier(e) 返回 Null 说明是瞬时态。如果一个实例没有持久化那他就是游离态，使用 PersistenceUnitUtil#getIdentifier(e) 可以返回实例的id值。你可以从 EntityManagerFactory 获取 PersistenceUnitUtil。</p>
<p>有两个问题需要注意下：第一，id 直到持久化上下文 flush 之后才会被赋值。第二，如果你的 id 使用的是基本数据类型，那么PersistenceUnitUtil#getIdentifier() 永远也不会返回 null。</p>
</blockquote>
<p>在用持久化上下文管理 Item 实例时最好先将它初始化。insert sql 语句会包含在调用 persist() 方法那一刻 entity 实例所拥有的属性值。如果你在持久化的时候没有给 Item 的 name 属性赋值，那就可能违反 name 不能为 null 的约束。你可以在调用 persist() 之后再更改 Item 的数据，Hibernate 会生成一个附加的 update 语句将更改同步到数据库中。</p>
<p>如果在执行 insert 或者 update 操作时 flush 失败，那么 Hibernate 会将在这次事务内对数据库的更改撤销（俗称回滚）。但是 Hibernate 不会回滚内存中的数据。如果，你在调用 persist() 之后修改了 Item#name ，这时事务提交失败了，将不会回滚到以前的 name 。这样做是很正常的，因为正常情况下事务提交失败了是不能恢复的，你必须立即丢弃这次事务相关的持久化上下文和 EntityManager。我们将在下一章讨论如何处理异常。</p>
<p>接下来，你要加载并且修改存储中的数据。</p>
<h3 id="查询并且修改持久化数据"><a href="#查询并且修改持久化数据" class="headerlink" title="查询并且修改持久化数据"></a>查询并且修改持久化数据</h3><p>你可以通过 EntityManager 从数据库中查找持久化实例。【我们假设，在前面章节例子中的某处你持有 Item 存储后的 id 属性值，然后你在一个新的工作单元中通过 id 查询相关实例数据：</p>
<p><img src="https://s2.loli.net/2021/12/15/X5TRCxmEZNo72q4.png" alt="image-20211215194153743"></p>
<p>下图展示的就是这个过程。</p>
<p><img src="https://s2.loli.net/2021/12/15/wsGI8KPXoOhqjnS.png" alt="image-20211215204430372"></p>
<p>你不需要强制类型装换 find() 操作获得的结果。这个方法返回的类型与第一个参数的类型相同。查询出来的 entity 实例是持久态的，你现在可以在工作单元中修改它。</p>
<p>如果没有与 id 想匹配的持久化实例，那 find() 方法就会返回 null。如果根据查询的 class 类型和 ID 不能在持久化上下文的缓存中命中数据，那就会去查询数据库。entity 实例在查询的过程中会被初始化，它会包含所有游离态转持久态时持有的数据：就像你保存数据后刷新页面一样。（如果开启了二级缓存那 Hibernate 或许不会查询数据库。我们将在 20.2 节进行学习）。</p>
<p>你可以修改 Item 实例，持久化上下文将会记住这些更改，并且在事务提交的时候执行相关 Sql,  自动将这些更改同步到数据库中。</p>
<p>Hibernate 在事务结束前，会尽可能晚的将数据同步到数据库中，因为 DML sql 语句会将数据库锁住，直到事务结束后才解开。所以 Hibernate 会尽可能减少锁住数据库的时间。</p>
<p>Hibernate 会使用 update sql 语句将 Item#name 写入数据库中。默认情况下，Hibernate update 语句会包含 ITEM 所有配置了映射的列，如果某些列还是持有的旧数据的值，那么它们也会再次执行，只不过是用旧值更新了旧值。如果你只想更新被更改的列，你可以启动 sql 动态生成功能，在 4.3.2 节有讨论过。</p>
<p>当 Item 从数据库中被加载出来时会生成一个副本的快照，Hibernate 通过与快照进行对比就可以发现 Item 的 name 被修改过。如果你的 Item 与快照不同，那就会执行 update 语句。这个快照会消耗持久化上下文的内存。同时通过快照进行脏数据检查也可能非常耗时，因为 Hibernate 在 flush 期间必须在持久化上下文中将所有 entity 实例与它们的快照进行对比。</p>
<p>你或许想通过拓展点对 Hibernate 脏数据检查的过程做自定义的配置。这个配置是 hibernate.entity_dirtiness_strategy ，你需要在  persistence.xml 中进行配置，它的 value 值应该为 org.hibernate.Custom-EntityDirtinessStrategy 实现类的全限定名。可以通过 Javadoc 了解这个接口的更多信息。同时，你也可以通过实现 org.hibernate.Interceptor 的 findDirty() 方法来自定义脏数据检查。你可以在 13.2.2 小结找到使用示例。</p>
<p>我们在前文说过，持久化上下文中的 entity 实例是可以重复读的，并且保证 entity 的 id 是唯一的。</p>
<p><img src="https://s2.loli.net/2021/12/16/6XyTUthC1cWa9GN.png" alt="image-20211216185841037"></p>
<p>第一次调用 find() 方法，会通过 select sql 将 Item 实例从数据库中查询出来了。第二次调用 find() 方法会从持久化上下文的缓存中查询 Item 实例，并返回查询结果。</p>
<p>有时，你需要用到某个 entity 实例，但是你并不想查询数据库。当你加载一个 entity 实例的时候，你并不想直接去查询数据库，因为你不确定是否需要完全的初始化它。这时，你可以通过 EntityManager 尝试获取这个实例被代理的引用。</p>
<p><img src="https://s2.loli.net/2021/12/16/t85TrWcfF2GN6Pn.png" alt="image-20211216191430362"></p>
<p>如果加载的这个 entity 实例早就已经存在持久化上下文中了，那 getReference() 就会返回内存中的这个实例，而不会去查询数据库。此外，如果当前持久化上下文中没有查询的 entity 实例，那么 Hibernate 将返回一个代理（一个虚拟的占位符）。这意味着 getReference() 方法不会访问数据库，并且它也不会返回 null。这一点与 find() 大不相同。</p>
<p>Jpa 提供  PersistenceUnitUtil#isLoaded() 方法去确定你正在使用的代理是不是还没有被初始化。</p>
<p>只要你调用这个代理的任何方法，就像 Item#getName() 方法，那么 Hibernate 就会执行 select 语句将这个占位符初始化。但是这个规则可能因为 id 的 getter 方法而抛出异常，例如 getId()。代理虽然看起来就像是真的 entity 实例一样，但是它只是持有 entity 实例 id 的占位符。如果在代理初始化的时候这条记录已经不在数据库中了，那么 Hibernate 就会抛出 EntityNotFoundException 异常。记住，当调用 Item#getName() 方法时可能会抛出异常。</p>
<p>Hibernate 提供了一个方便使用的静态方法 initialize() 去加载被代理的数据。</p>
<p>在持久化上下文关闭以后，item 会转变成游离态。如果你在持久化上下文开启的期间没有初始化这个代理，那么在持久化上下文关闭后你再访问代理就会抛出 LazyInitializationException 。持久化上下文关闭后你就不能继续加载数据了。解决办法也很简单：你在关闭持久化上下文之前加载数据。</p>
<p>我们会在12章详细介绍代理、懒加载和按需获取。</p>
<p>如何你想从数据库中删除一个 entity 实例，你必须把它转成瞬时态。</p>
<h3 id="让数据变瞬时态"><a href="#让数据变瞬时态" class="headerlink" title="让数据变瞬时态"></a>让数据变瞬时态</h3><p>通过调用 EntityManager#remove() 方法可以让 entity 实例变成瞬时态，同时从数据库中删除它。</p>
<p><img src="https://s2.loli.net/2021/12/16/9oYX1QmvsySTJef.png" alt="image-20211216200443088"></p>
<p>如果你调用 find() 方法，Hibernate 将通过 select 语句加载 item。如果你调用 getReference() HIbernate 将避免去查询数据库，并返回一个代理。</p>
<p>调用 remove() 方法可以在工作单元结束后删除这个 entity 实例；之后它会转成删除态。如果对代理使用 remove() 方法，那 Hibernate 将执行 select 语句去加载这个数据。在瞬时态， entity 实例必须完全初始化。你或许使用了生命周期回调函数或者 entity 监听器，实例必须将通过这些拦截器之后才能走完全部生命周期。</p>
<p>一个 entity 处于删除态就不再属于持久态了。你可以通过 contains() 方法去验证。</p>
<p>你可以让删除态的实例再一次转为持久态，从而取消这次删除操作。</p>
<p>当事务提交的时候，Hibernate 会通过 delete 语句将状态的转变同步到数据库中。JVM 的垃圾回收器会检查 item 是否还被 GCRoot 引用，如果没有就会将它们回收。</p>
<p>下图展示了这个流程：</p>
<p><img src="https://s2.loli.net/2021/12/16/bn1APtkdDuYSWKF.png" alt="image-20211216203925450"></p>
<p>默认情况下，Hibernate 在删除时不会改变 entity 实例 id 的数值。这意味着，item.getId() 方法会一直返回当时的数值。有时这是非常有用的，例如，你想要再次保存一个已经被删除的 Item 实例。在持久化上下文 flush 之前你可以掉用 persist() 去保存一个被删除的实例，从而这次取消删除操作。当然如果  persistence.xml 文件中的 hibernate.use_  identifier_  rollback 参数被设置为 true ，那 Hibernate 将会在删除的时候重新设置 id 的值。在前面的例子中，id 将被重新设置成默认值 null。现在 Item 转换成了瞬时态，然后你可以在一个新的持久化上下文中再一次保存它。</p>
<p>Java 持久层也提供了很多操作手段，可以在执行 delete sql 语句时不用经过拦截器处理。我们将在 20.1 节讨论这些操作。</p>
<p>假设你从数据库加载出来一个 entity 实例，并且在之后要使用它。因为某些原因，你知道在这个应用中的其他线程已经在数据库中更改了这条数据。下面我们将看下如何刷新内存中的数据。</p>
<h3 id="刷新数据"><a href="#刷新数据" class="headerlink" title="刷新数据"></a>刷新数据</h3><p>下面是一个刷新持久态  entity 实例的代码样例：</p>
<p><img src="https://s2.loli.net/2021/12/17/qXRurlM7VPpeDch.png" alt="image-20211217124717461"></p>
<p>当你加载 entity 实例之后，你了解到有谁更改了数据库的数据。那你就可以调用 refresh() 方法，这时 Hibernate 会执行 select 语句去读取数据库中的数据，并更新内存中的结果集，这样可以将更改重新写入已经加载到内存中的 entity 实例。当然，如果数据库中已经不存在这条数据了（例如某人删除了它），这时调用 refresh()  方法 Hibernate 会抛出 EntityNotFoundException 异常。</p>
<p>大多数应用都不必手动刷新内存数据；在事务提交时完成数据修改是很典型的场景。所以使用 refresh() 刷新内存的最佳场景是在使用一个被拓展的持久化上下文中，因为它可能横跨多个事务。例如，当你用一个已经创建好的持久化上下文等在用户输入时，数据可能已经过时了，所以在用户和系统交互的过程中需要不断刷新。如果用户关闭了会话，我们也可以用刷新操作来取消在内存中对数据的更改。我们将在 18.3 节对此进行更多的了解。</p>
<p>另一个非常有用的操作就是 entity 实例的复制操作。</p>
<h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>复制操作是非常有用的，例如，你想从一个数据库中获取数据，然后存储到另外一个数据库中。</p>
<p>复制操作会在一个持久化上下文中加载游离态实例，然后让他们持久化到另一个持久化上下文中。你通常会从两个不同的 EntityManagerFactory 配置中开启这些上下文，开启两个不同的数据库操作逻辑。为此你需要在这些配置中对 entity 进行映射。</p>
<p>replicate() 操作只在 Hibernate Session API 中有效。下面的例子就是展示如何从一个持久化上下文中复制数据然后存储到另一个中。</p>
<p><img src="https://s2.loli.net/2021/12/19/C5PRgjescwLNMzG.png" alt="image-20211219142210341"></p>
<p>两个数据库的连接可以在同一个事务中。</p>
<p>ReplicationMode 控制复制过程的细节，提供以下操作：</p>
<ul>
<li>IGNORE-如果在数据库中已经有同样 id 的数据了，那就忽略它。</li>
<li>OVERWRITE-覆盖拥有相同 id 的数据。</li>
<li>EXCEPTION-如果已经有相同 id 的数据了就抛异常。</li>
<li>LATEST_VERSION-如果数据库中现有数据的版本低于待复制数据的版本，那就覆盖旧版本数据，否则就忽略它。需要开启 entity 版本控制功能的乐观锁并发控制配置 （可以参考 11.2.2 章节）。</li>
</ul>
<p>当你需要把不同数据库中的数据同步成相同的数据时就需要复制操作了。举一个产品升级的例子：当你的新版本应用需要更换成一个新的数据库时，你可能想要一次性的复制并且替换掉已经存在的数据。</p>
<p>持久化上下文可以为你做很多事情：就像可以在同一个上下文中保证 id 唯一，等等还有很多其他类似的操作。所以你了解它的运行流程是很重要的，这让你可以知道背后发生了什么。</p>
<h3 id="缓存在持久化上下文中的使用"><a href="#缓存在持久化上下文中的使用" class="headerlink" title="缓存在持久化上下文中的使用"></a>缓存在持久化上下文中的使用</h3><p>持久化上下文其实就是持久化实例的缓存。任何持久态的实例都与持久化上下文密切相关。</p>
<p>许多人在使用 HIbernate 时忽略了这个简单的事实，导致系统抛出 OutOfMemoryException。当你在一个工作单元中加载了数以千计的 entity 实例，并且没有打算对他们进行修改时就很容易发生。Hibernate 会在持久化上下文中为每个 entity 实例都创建一个快照，这样很容易将内存耗尽。（显然，你如果要更改数以千计的数据，那你需要执行一个批量数据操作，我们将在 20.1 章节进行介绍）。</p>
<p>持久化上下文缓存不会自动减小。你需要将它的大小设置成不影响系统运行情况下的最小值。通常，很多上下文中的持久化实例都是因为意外情况才被加载出来的。例如，你只需要少量 item ，但是你却加载出很多你并不需要的 item 。一个巨大的图表可以对性能造成很大的影响，并且需要大量的内存去存储 entity 的快照，所以，要检查查询功能是否只返回的你需要的数据，并且考虑通过以下方法控制 Hibernate 缓存的行为。</p>
<p>调用 EntityManager#detach(i) 可以将一个 entity 实例从持久化上下文中删除。你可以调用 EntityManager#clear() 来清空持久化上下文。</p>
<p>在 Session api 中你可找到其他一些有用的方法。你可以让持久化上下文变成只读的。这样就不会生成 entity 快照和进行脏数据检查了，同时，也不能将更改写入到数据库了。</p>
<p><img src="https://s2.loli.net/2021/12/19/ghmaxJjW3IUS9F1.png" alt="image-20211219151042783"></p>
<p>你也可以只关闭一个 entity 实例的脏数据检查：</p>
<p><img src="https://s2.loli.net/2021/12/19/PzHO3d9k8vXAfql.png" alt="image-20211219151146830"></p>
<p>org.hibernate.Query 接口可以返回一个只读结果，Hibernate 不会对它们的更改进行检查。</p>
<p><img src="https://s2.loli.net/2021/12/19/w7dFe6iu4rNRCnK.png" alt="image-20211219151317561"></p>
<p>你也可以通过标准 JAP 接口 javax.persistence.Query 获得不做脏数据检查的实例 ，接口如下：</p>
<p><img src="https://s2.loli.net/2021/12/19/PATRMZfu7KCnjbX.png" alt="image-20211219151721724"></p>
<p>要注意使用只读的 entity 实例，你通常可以删除它们，但是在集合中更改是很困难的。Hibernate 手册有很多关于集合映射的案例需要你去了解，当然你也将在 14 章看到更多的查询样例。</p>
<p>到目前为止，在事务提交的时候 flush 操作和持久化上下文的同步都是自动进行的。但是在一些特殊场景中，你需要对同步数据的过程有更多的掌控。</p>
<h3 id="刷新持久化上下文"><a href="#刷新持久化上下文" class="headerlink" title="刷新持久化上下文"></a>刷新持久化上下文</h3><p>默认情况下，在事务提交的时候 Hibernate 会刷新持久化上下文，并将数据的更改同步到数据库中。在前面几章的例子中都是使用的这个策略。JPA 在以下场景中允许自动同步持久化上下文。</p>
<p>Hibernate 是 JPA 的一种实现，在以下几种情况会同步数据：</p>
<ul>
<li>当参与的 JTA 事务提交时。</li>
<li>在一个查询执行前–我们的意思不是使用 find() 方法进行查找，而是使用类似 javax.persistence.Query 这种 Hibernate api 进行查询。</li>
<li>当应用调用 flush() 方法。</li>
</ul>
<p>你可以使用 EntityManager 的 FlushModeType 设置控制这些行为：</p>
<p> <img src="https://s2.loli.net/2021/12/19/IiwZCxjrY5za2FN.png" alt="image-20211219174324733"></p>
<p>你在①加载了 Item 实例，并在②更改了它的名字。③然后你查询这条数据，并收到它的名字。通常，Hibernate 会在查询之前将内存中的更改同步到数据库中。这是 FlushModeType.AUTO 的行为，而这个行为是 Entity-Manager 参与事务的默认选项。FlushModeType.COMMIT 会关闭这个行为，所以可能导致查询出来的结果与内存中的数据不一致。只有事务提交的时候数据才会被同步到数据库中。</p>
<p>你可以通过调用 EntityManager#flush() 方法，在事务的任意时刻将数据的更改强制同步到数据库中。</p>
<p>我们关于瞬时态、持久化、删除 entity 状态以及 EntityManager API 的基本使用的讨论就此结束。控制状态转换的 API 方法必须要了解，每个 JPA 应用都有这些操作。</p>
<p>下面看下 entity 游离态。我们早就提到过当 entity 实例与持久化上下文彻底失去联系时会有一些问题，例如，不能进行延迟初始化。让我们通过一些样例去研究一下游离态，让你知道当我们在使用已经脱离持久化上下文管理的数据时会发生什么。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>ORM</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
</search>
