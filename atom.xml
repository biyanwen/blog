<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>byw的博客</title>
  <icon>http://biyw.cf/icon.png</icon>
  <subtitle>道阻且长，行则将至</subtitle>
  <link href="http://biyw.cf/atom.xml" rel="self"/>
  
  <link href="http://biyw.cf/"/>
  <updated>2022-01-08T14:41:49.860Z</updated>
  <id>http://biyw.cf/</id>
  
  <author>
    <name>Byw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>指令详解-寻址方式</title>
    <link href="http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-01-08T14:41:49.860Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;数据寻址&quot;&gt;&lt;a href=&quot;#数据寻址&quot; class=&quot;headerlink&quot; title=&quot;数据寻址&quot;&gt;&lt;/a&gt;数据寻址&lt;/h2&gt;&lt;p&gt;简单来说就是根据地址码取数据。&lt;/p&gt;
&lt;p&gt;指令中通常会增加一个寻址特征字段，这个字段就是告诉操作系统如何取数据的，如图：因为不同寻址方式的实现不同，所以地址码中存储的并不一定是真实的数据地址，所以这里用形式地址代替。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/08/buwDO8aYx3I5npg.png&quot; alt=&quot;image-20220108103344939&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据寻址特征的不同通常将寻址方式分为以下几类。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="http://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令详解-操作码</title>
    <link href="http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3-%E6%93%8D%E4%BD%9C%E7%A0%81/"/>
    <id>http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3-%E6%93%8D%E4%BD%9C%E7%A0%81/</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-01-08T14:42:58.971Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;定长编码&quot;&gt;&lt;a href=&quot;#定长编码&quot; class=&quot;headerlink&quot; title=&quot;定长编码&quot;&gt;&lt;/a&gt;定长编码&lt;/h2&gt;&lt;p&gt;每条指令的操作码都是固定长度。当操作码是 n 位时，指令最多有 2^n 条。&lt;br&gt;优点：计算机的硬件设计简单，朱令译码和执行速度快。&lt;br&gt;缺点：当指令数量增多、指令字单独为操作码划分出固定的多位后，留给表示操作数地址的位数会严重不足。&lt;br&gt;适用环境：适用于字长较长的计算机系统，如 32 位及以上。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="http://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令详解-地址码</title>
    <link href="http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3_%E5%9C%B0%E5%9D%80%E7%A0%81/"/>
    <id>http://biyw.cf/%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3_%E5%9C%B0%E5%9D%80%E7%A0%81/</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-01-08T14:43:07.906Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;指令是什么：&quot;&gt;&lt;a href=&quot;#指令是什么：&quot; class=&quot;headerlink&quot; title=&quot;指令是什么：&quot;&gt;&lt;/a&gt;指令是什么：&lt;/h2&gt;&lt;p&gt;可以将指令当做一种编程语言，表现形式为一串二进制码，作用是能让计算机按照指令去工作。&lt;/p&gt;
&lt;p&gt;指令由两部分组成，操作码和地址码，下面我们着重看下&lt;strong&gt;地址码&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="http://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java中byte转int为什么要使用&amp;0xFF</title>
    <link href="http://biyw.cf/Java%E4%B8%ADbyte%E8%BD%ACint%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-0xFF/"/>
    <id>http://biyw.cf/Java%E4%B8%ADbyte%E8%BD%ACint%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-0xFF/</id>
    <published>2022-01-03T05:50:35.000Z</published>
    <updated>2022-01-03T09:02:25.529Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Java 中将十六进制 byte 转成 int 时要使用 &amp;amp;0xFF 操作这是为什么呢？这是因为十六进制的范围是 0x00~0x3FF 没有负数，而 int 的取值范围是包含负数的，所以直接将 byte 强转成 int 可能会得到错误的数值。同时操作系统存储的是二进制原码进行补码后的数值, 所以只有通过 &amp;amp;0xFF 操作才能得到正确的数值。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="计算机原理" scheme="http://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 事务和并发篇(一)</title>
    <link href="http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E7%AF%87-%E4%B8%80/"/>
    <id>http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E7%AF%87-%E4%B8%80/</id>
    <published>2021-12-24T08:20:01.000Z</published>
    <updated>2021-12-26T10:51:41.014Z</updated>
    
    
    <summary type="html">&lt;p&gt;在这章，我们终于要学习事务相关的知识了：在应用中如何创建工作单元并解决并发问题。（ps: 想了解什么是 &lt;a href=&quot;https://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%BA%8C/&quot;&gt;工作单元&lt;/a&gt; 请看这里。）工作单元是一个原子操作。事务可以让你设置工作单元的边界，让其不会受其他工作单元影响。在一个拥有许多用户的应用中，或许会有很多人同时访问这些工作单元的情况。&lt;/p&gt;
&lt;p&gt;在处理并发问题之前，我们首先集中精力了解下最基础的工作单元：数据库和系统事务。你将学会使用 Java 代码定义工作单元和事务划分相关的 API。我们将讨论如何保持隔离，并且用乐观锁和悲观锁控制并发访问。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="http://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="http://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(三)</title>
    <link href="http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%B8%89/"/>
    <id>http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%B8%89/</id>
    <published>2021-12-19T14:05:23.000Z</published>
    <updated>2021-12-24T07:47:51.780Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;使用游离态&quot;&gt;&lt;a href=&quot;#使用游离态&quot; class=&quot;headerlink&quot; title=&quot;使用游离态&quot;&gt;&lt;/a&gt;使用游离态&lt;/h2&gt;&lt;p&gt;如果一个 entity 实例脱离了持久化上下文的管理，我们就称它为游离态。当持久化上下文关闭之后，它就不再提供 id 映射服务。当你使用游离态的 entity 实例时可能会遇到一些问题，所以，一定要保证你明白如何处理游离态实例。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="http://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="http://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(二)</title>
    <link href="http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%BA%8C/"/>
    <id>http://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%BA%8C/</id>
    <published>2021-12-12T13:56:51.000Z</published>
    <updated>2021-12-25T09:05:25.676Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;EntityManager-接口&quot;&gt;&lt;a href=&quot;#EntityManager-接口&quot; class=&quot;headerlink&quot; title=&quot;EntityManager 接口&quot;&gt;&lt;/a&gt;EntityManager 接口&lt;/h2&gt;&lt;p&gt;任何持久层框架都会提供一个管理持久层的 API。这个 API 一般都会提供基础的增删改查功能，通过它就可以管理持久化上下文。在 Java 持久层框架中，最常使用的接口就是 EntityManager。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="http://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="http://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(一)</title>
    <link href="http://biyw.cf/Hibernate_%E5%AE%9E%E6%88%98_%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%861/"/>
    <id>http://biyw.cf/Hibernate_%E5%AE%9E%E6%88%98_%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%861/</id>
    <published>2021-12-12T13:33:45.567Z</published>
    <updated>2021-12-19T12:58:50.995Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;管理数据&quot;&gt;&lt;a href=&quot;#管理数据&quot; class=&quot;headerlink&quot; title=&quot;管理数据&quot;&gt;&lt;/a&gt;管理数据&lt;/h2&gt;&lt;h3 id=&quot;entity-持久化过程中的生命周期&quot;&gt;&lt;a href=&quot;#entity-持久化过程中的生命周期&quot; class=&quot;headerlink&quot; title=&quot;entity 持久化过程中的生命周期&quot;&gt;&lt;/a&gt;entity 持久化过程中的生命周期&lt;/h3&gt;&lt;p&gt;因为 JPA 是一种透明的持久化机制，classes 不用关心他们自己的持久化行为，这样在写业务代码时就不需要关心数据是会被持久化还是仅仅保存在内存中。&lt;/p&gt;
&lt;p&gt;应用层在调用方法时真的没必要关心实体的持久化。例如，你在调用Item#calculate-TotalPrice()业务方法时一点也不用关心持久化的事情。任何与持久化有关的应用，无论是否要把内存的数据保存到数据库中都必须使用持久化服务。换句话说，你必须使用 Java Persistence 的接口存储和查询数据。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="http://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="http://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch，CyclicBarrier，Semaphore及AQS介绍</title>
    <link href="http://biyw.cf/CountDownLatch%EF%BC%8CCyclicBarrier%EF%BC%8CSemaphore%E5%8F%8AAQS%E4%BB%8B%E7%BB%8D/"/>
    <id>http://biyw.cf/CountDownLatch%EF%BC%8CCyclicBarrier%EF%BC%8CSemaphore%E5%8F%8AAQS%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-12-05T07:10:31.558Z</published>
    <updated>2021-12-16T04:39:34.433Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;CountDownLatch适用于在多线程的场景需要等待所有子线程全部执行完毕之后再做操作的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="多线程" scheme="http://biyw.cf/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码阅读" scheme="http://biyw.cf/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://biyw.cf/Redis%E5%92%8CZookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://biyw.cf/Redis%E5%92%8CZookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2021-12-05T06:57:16.379Z</published>
    <updated>2021-12-16T04:40:53.454Z</updated>
    
    
    <summary type="html">&lt;p&gt;在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。 但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。 当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
    <category term="分布式" scheme="http://biyw.cf/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="多线程" scheme="http://biyw.cf/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【通过抓包学网络】TCP三次握手与四次挥手﻿</title>
    <link href="http://biyw.cf/%E3%80%90%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%AD%A6%E7%BD%91%E7%BB%9C%E3%80%91TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://biyw.cf/%E3%80%90%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%AD%A6%E7%BD%91%E7%BB%9C%E3%80%91TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2021-12-05T06:47:29.126Z</published>
    <updated>2021-12-16T04:43:03.222Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文章是通过wireshark来抓包的，如果你对这个工具不熟悉可以看这篇文章&lt;a href=&quot;https://blog.csdn.net/qq_43005544/article/details/116504407&quot;&gt;wireshark 简易教程&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Wireshark" scheme="http://biyw.cf/tags/Wireshark/"/>
    
    <category term="网络" scheme="http://biyw.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark 简明教程</title>
    <link href="http://biyw.cf/wireshark%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>http://biyw.cf/wireshark%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</id>
    <published>2021-12-05T06:42:55.422Z</published>
    <updated>2021-12-16T04:43:41.419Z</updated>
    
    
    <summary type="html">&lt;p&gt;Wireshark 作为一款免费的抓包工具深受工程师们的喜爱，下面就简单介绍一下如何使用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Wireshark" scheme="http://biyw.cf/tags/Wireshark/"/>
    
    <category term="网络" scheme="http://biyw.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Git-submodule 统一配置简明教程</title>
    <link href="http://biyw.cf/git-submodule%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://biyw.cf/git-submodule%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</id>
    <published>2021-12-05T06:41:25.950Z</published>
    <updated>2021-12-16T04:42:13.195Z</updated>
    
    
    <summary type="html">&lt;p&gt;随着公司的不断发展，为了提高系统的容灾能力以及功能模块的复用程度，不断有更多的项目引入了微服务的概念，但是随着业务复杂度不断的上升，拆分模块的数量也越来越多，统一管理众多模块的配置文件的需求就应运而生。&lt;/p&gt;
&lt;p&gt;git-submodule 是 git 提供的一个功能模块， 它允许一个 git 仓库，作为另一个 git 仓库的子目录，并且保持父项目和子项目相互独立。通过这个功能模块我们就可以让多个项目同时使用一个 git 仓库的代码进行开发。由此可以实现配置的统一管理。&lt;/p&gt;
&lt;p&gt;之所以选用 git-submodule 是因为它足够简单，学习成本低；侵入性小，不需要系统做很多更改。但是所有事情都有两面，他也有一些缺点，比如功能单一，不够灵活。虽然它有这些缺点，但是对于使用场景比较单间的项目就足够了，并不是功能越多越好，适合的才是最好的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Git" scheme="http://biyw.cf/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>【Mybatis源码解读】jdbc包</title>
    <link href="http://biyw.cf/%E3%80%90Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E3%80%91jdbc%E5%8C%85/"/>
    <id>http://biyw.cf/%E3%80%90Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E3%80%91jdbc%E5%8C%85/</id>
    <published>2021-12-05T06:30:01.964Z</published>
    <updated>2021-12-16T04:45:24.272Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-jdbc包的作用&quot;&gt;&lt;a href=&quot;#1-jdbc包的作用&quot; class=&quot;headerlink&quot; title=&quot;1. jdbc包的作用&quot;&gt;&lt;/a&gt;1. jdbc包的作用&lt;/h2&gt;&lt;p&gt;jdbc包作为Mybatis框架的核心包之一可以理解为是&lt;strong&gt;操作Sql的工具包&lt;/strong&gt;，因为通过阅读代码观察到这个jdbc包里面的类并没有被Mybatis框架本身引用，而其本身的作用又是对sql的操作，所以当作工具包来理解是没有什么问题的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mybatis" scheme="http://biyw.cf/tags/Mybatis/"/>
    
    <category term="源码阅读" scheme="http://biyw.cf/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>常见的Web应用攻击手段</title>
    <link href="http://biyw.cf/%E5%B8%B8%E8%A7%81%E7%9A%84Web%E5%BA%94%E7%94%A8%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/"/>
    <id>http://biyw.cf/%E5%B8%B8%E8%A7%81%E7%9A%84Web%E5%BA%94%E7%94%A8%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5/</id>
    <published>2021-12-05T06:24:20.623Z</published>
    <updated>2021-12-16T04:45:49.346Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-XSS攻击&quot;&gt;&lt;a href=&quot;#1-XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;1.XSS攻击&quot;&gt;&lt;/a&gt;1.XSS攻击&lt;/h2&gt;&lt;p&gt;XSS攻击即跨站点脚本攻击（Cross Site Script），指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://biyw.cf/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>集群环境下如何管理Session</title>
    <link href="http://biyw.cf/%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Session/"/>
    <id>http://biyw.cf/%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Session/</id>
    <published>2021-12-05T06:21:36.434Z</published>
    <updated>2021-12-16T04:44:57.671Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-Session复制&quot;&gt;&lt;a href=&quot;#1-Session复制&quot; class=&quot;headerlink&quot; title=&quot;1.Session复制&quot;&gt;&lt;/a&gt;1.Session复制&lt;/h2&gt;&lt;p&gt;应用服务器开启Web容器的Session复制功能，在集群中的几台服务器之间同步Session对象，使得每台服务器上都保存所有用户的Session信息，这样任何一台机器宕机都不会导致Session数据的丢失，而服务器使用Session时，也只需要在本机获取即可&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://biyw.cf/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网站的高性能架构</title>
    <link href="http://biyw.cf/%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/"/>
    <id>http://biyw.cf/%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/</id>
    <published>2021-12-05T06:20:42.235Z</published>
    <updated>2021-12-16T04:44:41.665Z</updated>
    
    
    <summary type="html">&lt;p&gt;网站性能是客观的指标，可以具体体现到响应时间、吞吐量等技术指标，同时也是主观的感受，而感受则是一种与具体参与者相关的微妙的东西，用户的感受和工程师的感受不同，不同的用户感受也不同。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://biyw.cf/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网站典型故障案例</title>
    <link href="http://biyw.cf/%E7%BD%91%E7%AB%99%E5%85%B8%E5%9E%8B%E6%95%85%E9%9A%9C%E6%A1%88%E4%BE%8B/"/>
    <id>http://biyw.cf/%E7%BD%91%E7%AB%99%E5%85%B8%E5%9E%8B%E6%95%85%E9%9A%9C%E6%A1%88%E4%BE%8B/</id>
    <published>2021-12-05T06:18:51.996Z</published>
    <updated>2021-12-16T04:44:31.803Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;1-写日志也会引发故障&quot;&gt;&lt;a href=&quot;#1-写日志也会引发故障&quot; class=&quot;headerlink&quot; title=&quot;1.写日志也会引发故障&quot;&gt;&lt;/a&gt;1.写日志也会引发故障&lt;/h2&gt;&lt;h3 id=&quot;故障现象&quot;&gt;&lt;a href=&quot;#故障现象&quot; class=&quot;headerlink&quot; title=&quot;故障现象&quot;&gt;&lt;/a&gt;故障现象&lt;/h3&gt;&lt;p&gt;某应用服务器在项目发布后不久就出现报警，硬盘可用空间低于警戒值，并且很快就宕机。登录到线上服务器，发现log文件夹里的文件迅速增加，不断消耗磁盘空间。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://biyw.cf/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="问题记录" scheme="http://biyw.cf/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程</title>
    <link href="http://biyw.cf/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://biyw.cf/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-12-05T06:16:49.258Z</published>
    <updated>2021-12-16T04:46:03.334Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h2&gt;&lt;p&gt;内存模型一词可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；&lt;br&gt;在jdk5发布后Java内存模型才终于成熟、完善起来&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://biyw.cf/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="http://biyw.cf/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://biyw.cf/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-12-05T06:15:11.402Z</published>
    <updated>2021-12-16T04:46:23.344Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h2&gt;&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当前线程所执行的字节码的行号指示器，用来选取下一条需要执行的字节码指令&lt;/li&gt;
&lt;li&gt;线程私有&lt;/li&gt;
&lt;li&gt;唯一一个不会出现OOM的区域&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="http://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Jvm" scheme="http://biyw.cf/tags/Jvm/"/>
    
  </entry>
  
</feed>
