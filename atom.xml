<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>byw的博客</title>
  <icon>https://biyw.cf/icon.png</icon>
  <subtitle>道阻且长，行则将至</subtitle>
  <link href="https://biyw.cf/atom.xml" rel="self"/>
  
  <link href="https://biyw.cf/"/>
  <updated>2022-02-19T07:48:07.607Z</updated>
  <id>https://biyw.cf/</id>
  
  <author>
    <name>Byw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一致性算法-Zab</title>
    <link href="https://biyw.cf/posts/238f0bdc.html"/>
    <id>https://biyw.cf/posts/238f0bdc.html</id>
    <published>2022-02-19T05:45:00.000Z</published>
    <updated>2022-02-19T07:48:07.607Z</updated>
    
    
    <summary type="html">&lt;p&gt;Zab 算法出现在 Paxos 之后、Raft 之前，其实 Raft 的很多思路和Zab很像，我们熟知的 Zookeeper 使用的就是 Zab 算法。&lt;/p&gt;
&lt;p&gt;与 Raft 相似，Zab 也分为三个阶段，分别是阶段一，选举 Leader；阶段二，同步数据；阶段三，崩溃恢复。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://biyw.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法-Raft</title>
    <link href="https://biyw.cf/posts/abf4a6b7.html"/>
    <id>https://biyw.cf/posts/abf4a6b7.html</id>
    <published>2022-02-15T05:01:16.000Z</published>
    <updated>2022-02-19T03:08:53.389Z</updated>
    
    
    <summary type="html">&lt;p&gt;Paxos 算法虽然在一段时间内已经成了一致性算法的代名词。但是它也是出了名的艰深晦涩，并且当时基于 Paxos 的成熟工程少之又少。在这种情况下就有人设计了 Raft 算法，Raft 算法将”可理解性”放在了第一位。下面就让我们看下 Raft 算法的运行流程。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://biyw.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法-Paxos</title>
    <link href="https://biyw.cf/posts/8bee0b02.html"/>
    <id>https://biyw.cf/posts/8bee0b02.html</id>
    <published>2022-02-09T11:20:44.000Z</published>
    <updated>2022-02-10T11:01:57.686Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Paxos-是如何保证一致性的&quot;&gt;&lt;a href=&quot;#Paxos-是如何保证一致性的&quot; class=&quot;headerlink&quot; title=&quot;Paxos 是如何保证一致性的&quot;&gt;&lt;/a&gt;Paxos 是如何保证一致性的&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;答案是通过持久化变化的日志流来保证一致性的。&lt;/strong&gt;你会问这是为什么。这需要你带着这个问题来看下面的示例：&lt;/p&gt;
&lt;p&gt;如图：我们现在部署了三个节点的集群，分别是 Node 1,Node 2,Node 3。这三个节点中的任何一个节点都可以写入数据，同时任何一个节点被写入数据后都会将数据同步给其他两个节点，现在有三个客户端分别在三个节点写入 a, b, c。问，当查询的时候数据按照哪种顺序排列是正确的？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://biyw.cf/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-InnoDB缓存详解</title>
    <link href="https://biyw.cf/posts/e7489af5.html"/>
    <id>https://biyw.cf/posts/e7489af5.html</id>
    <published>2022-02-04T07:27:16.000Z</published>
    <updated>2022-02-04T08:33:05.783Z</updated>
    
    
    <summary type="html">&lt;p&gt;Mysql 的缓存叫做 Buffer Pool 它的主要作用就是将一些数据存储在内存中，当数据库需要访问的时候直接访问内存中的数据，而不用重新从磁盘中加载，减少磁盘 IO，提高系统运行效率。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mysql" scheme="https://biyw.cf/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-InnoDB表空间详解</title>
    <link href="https://biyw.cf/posts/720913d1.html"/>
    <id>https://biyw.cf/posts/720913d1.html</id>
    <published>2022-02-03T02:42:51.000Z</published>
    <updated>2022-02-03T08:07:12.573Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是表空间&quot;&gt;&lt;a href=&quot;#什么是表空间&quot; class=&quot;headerlink&quot; title=&quot;什么是表空间&quot;&gt;&lt;/a&gt;什么是表空间&lt;/h2&gt;&lt;p&gt;表空间是 Mysql 的一个抽象概念，在你新建一个表的时候，Mysql （5.7 + 版本）会为这个表创建一个后缀为 ibd 的文件，这个文件的名字就是表空间，构成表空间的最小单位就是页，所以表空间是实际存储索引和用户数据的地方。因为一个页最多 16k 大小，所以一个表空间拥有页的数量会特别巨大，为了更方便的对页进行管理，Mysql 的作者发明了&lt;code&gt;区&lt;/code&gt;的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mysql" scheme="https://biyw.cf/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-InnoDB索引详解</title>
    <link href="https://biyw.cf/posts/b7cc2c3.html"/>
    <id>https://biyw.cf/posts/b7cc2c3.html</id>
    <published>2022-02-01T05:54:01.000Z</published>
    <updated>2022-02-03T08:07:12.571Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;索引的作用&quot;&gt;&lt;a href=&quot;#索引的作用&quot; class=&quot;headerlink&quot; title=&quot;索引的作用&quot;&gt;&lt;/a&gt;索引的作用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引的作用就是能够让我们快速的查到想要的数据&lt;/strong&gt;。上一篇文章我们介绍了 Mysql 在内存中存储数据的单位&lt;code&gt;页&lt;/code&gt;，Mysql 从磁盘加载数据的时候会在内存中创建以&lt;code&gt;页&lt;/code&gt;为节点的双向链表，我们已经了解到在&lt;code&gt;页&lt;/code&gt;中查找数据可以通过二分查找法快速检索到数据，但是要确定数据在哪个页中就要一个页一个页的查找（如果你对在页中查找数据的过程有疑问，请查看上一篇博客），这个逻辑显然是不合理的，因为 Mysql 是能够存储大量数据的，所以这个双向链表会很长查找速度会很慢。为了解决这个问题，Mysql 的开发者创建了索引这个功能来达到快速查找数据的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mysql" scheme="https://biyw.cf/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-InnoDB页详解</title>
    <link href="https://biyw.cf/posts/6d95a3c4.html"/>
    <id>https://biyw.cf/posts/6d95a3c4.html</id>
    <published>2022-01-16T05:53:42.000Z</published>
    <updated>2022-02-03T08:07:12.575Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;页的作用&quot;&gt;&lt;a href=&quot;#页的作用&quot; class=&quot;headerlink&quot; title=&quot;页的作用&quot;&gt;&lt;/a&gt;页的作用&lt;/h2&gt;&lt;p&gt;什么是页？页是 Mysql 从磁盘中加载数据的最小单位。页的大小为 16 kb。&lt;/p&gt;
&lt;p&gt;为什么要按页加载数据呢？首先我们都知道磁盘 IO 是比较慢的，如果每查一条数据都要从磁盘中读取数据的话性能是很差的。所以当查询一条数据的时候 Mysql 会从磁盘中将与这条数据相近的数据都加载到内存中，这样可以大幅度提高性能。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mysql" scheme="https://biyw.cf/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>位运算学习笔记</title>
    <link href="https://biyw.cf/posts/25cb8793.html"/>
    <id>https://biyw.cf/posts/25cb8793.html</id>
    <published>2022-01-09T08:13:18.000Z</published>
    <updated>2022-02-03T08:07:12.590Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;位运算符&quot;&gt;&lt;a href=&quot;#位运算符&quot; class=&quot;headerlink&quot; title=&quot;位运算符&quot;&gt;&lt;/a&gt;位运算符&lt;/h2&gt;&lt;h3 id=&quot;位逻辑运算符&quot;&gt;&lt;a href=&quot;#位逻辑运算符&quot; class=&quot;headerlink&quot; title=&quot;位逻辑运算符&quot;&gt;&lt;/a&gt;位逻辑运算符&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;a &amp;amp; b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;a | b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;取反&lt;/td&gt;
&lt;td&gt;~a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;异或&lt;/td&gt;
&lt;td&gt;a ^ b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&quot;逻辑运算结果集&quot;&gt;&lt;a href=&quot;#逻辑运算结果集&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算结果集&quot;&gt;&lt;/a&gt;逻辑运算结果集&lt;/h4&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="https://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令详解-寻址方式</title>
    <link href="https://biyw.cf/posts/def90db1.html"/>
    <id>https://biyw.cf/posts/def90db1.html</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-02-03T08:07:12.596Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;数据寻址&quot;&gt;&lt;a href=&quot;#数据寻址&quot; class=&quot;headerlink&quot; title=&quot;数据寻址&quot;&gt;&lt;/a&gt;数据寻址&lt;/h2&gt;&lt;p&gt;简单来说就是根据地址码取数据。&lt;/p&gt;
&lt;p&gt;指令中通常会增加一个寻址特征字段，这个字段就是告诉操作系统如何取数据的，如图：因为不同寻址方式的实现不同，所以地址码中存储的并不一定是真实的数据地址，所以这里用形式地址代替。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/08/buwDO8aYx3I5npg.png&quot; alt=&quot;image-20220108103344939&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据寻址特征的不同通常将寻址方式分为以下几类。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="https://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令详解-地址码</title>
    <link href="https://biyw.cf/posts/adb2ba17.html"/>
    <id>https://biyw.cf/posts/adb2ba17.html</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-02-03T08:07:12.600Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;指令是什么：&quot;&gt;&lt;a href=&quot;#指令是什么：&quot; class=&quot;headerlink&quot; title=&quot;指令是什么：&quot;&gt;&lt;/a&gt;指令是什么：&lt;/h2&gt;&lt;p&gt;可以将指令当做一种编程语言，表现形式为一串二进制码，作用是能让计算机按照指令去工作。&lt;/p&gt;
&lt;p&gt;指令由两部分组成，操作码和地址码，下面我们着重看下&lt;strong&gt;地址码&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="https://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令详解-操作码</title>
    <link href="https://biyw.cf/posts/94f9446a.html"/>
    <id>https://biyw.cf/posts/94f9446a.html</id>
    <published>2022-01-08T05:50:35.000Z</published>
    <updated>2022-02-03T08:07:12.598Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;定长编码&quot;&gt;&lt;a href=&quot;#定长编码&quot; class=&quot;headerlink&quot; title=&quot;定长编码&quot;&gt;&lt;/a&gt;定长编码&lt;/h2&gt;&lt;p&gt;每条指令的操作码都是固定长度。当操作码是 n 位时，指令最多有 2^n 条。&lt;br&gt;优点：计算机的硬件设计简单，朱令译码和执行速度快。&lt;br&gt;缺点：当指令数量增多、指令字单独为操作码划分出固定的多位后，留给表示操作数地址的位数会严重不足。&lt;br&gt;适用环境：适用于字长较长的计算机系统，如 32 位及以上。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机原理" scheme="https://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java中byte转int为什么要使用&amp;0xFF</title>
    <link href="https://biyw.cf/posts/1d17d658.html"/>
    <id>https://biyw.cf/posts/1d17d658.html</id>
    <published>2022-01-03T05:50:35.000Z</published>
    <updated>2022-02-03T08:07:12.568Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 Java 中将十六进制 byte 转成 int 时要使用 &amp;amp;0xFF 操作这是为什么呢？这是因为十六进制的范围是 0x00~0x3FF 没有负数，而 int 的取值范围是包含负数的，所以直接将 byte 强转成 int 可能会得到错误的数值。同时操作系统存储的是二进制原码进行补码后的数值, 所以只有通过 &amp;amp;0xFF 操作才能得到正确的数值。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="计算机原理" scheme="https://biyw.cf/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 事务和并发篇(一)</title>
    <link href="https://biyw.cf/posts/2622ec0e.html"/>
    <id>https://biyw.cf/posts/2622ec0e.html</id>
    <published>2021-12-24T08:20:01.000Z</published>
    <updated>2022-02-03T08:07:12.557Z</updated>
    
    
    <summary type="html">&lt;p&gt;在这章，我们终于要学习事务相关的知识了：在应用中如何创建工作单元并解决并发问题。（ps: 想了解什么是 &lt;a href=&quot;https://biyw.cf/Hibernate-%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88-%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91-%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%AF%87-%E4%BA%8C/&quot;&gt;工作单元&lt;/a&gt; 请看这里。）工作单元是一个原子操作。事务可以让你设置工作单元的边界，让其不会受其他工作单元影响。在一个拥有许多用户的应用中，或许会有很多人同时访问这些工作单元的情况。&lt;/p&gt;
&lt;p&gt;在处理并发问题之前，我们首先集中精力了解下最基础的工作单元：数据库和系统事务。你将学会使用 Java 代码定义工作单元和事务划分相关的 API。我们将讨论如何保持隔离，并且用乐观锁和悲观锁控制并发访问。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="https://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="https://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(三)</title>
    <link href="https://biyw.cf/posts/edd61a92.html"/>
    <id>https://biyw.cf/posts/edd61a92.html</id>
    <published>2021-12-19T14:05:23.000Z</published>
    <updated>2022-02-03T08:07:12.570Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;使用游离态&quot;&gt;&lt;a href=&quot;#使用游离态&quot; class=&quot;headerlink&quot; title=&quot;使用游离态&quot;&gt;&lt;/a&gt;使用游离态&lt;/h2&gt;&lt;p&gt;如果一个 entity 实例脱离了持久化上下文的管理，我们就称它为游离态。当持久化上下文关闭之后，它就不再提供 id 映射服务。当你使用游离态的 entity 实例时可能会遇到一些问题，所以，一定要保证你明白如何处理游离态实例。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="https://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="https://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(二)</title>
    <link href="https://biyw.cf/posts/93253ab9.html"/>
    <id>https://biyw.cf/posts/93253ab9.html</id>
    <published>2021-12-12T13:56:51.000Z</published>
    <updated>2022-02-03T08:07:12.613Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;EntityManager-接口&quot;&gt;&lt;a href=&quot;#EntityManager-接口&quot; class=&quot;headerlink&quot; title=&quot;EntityManager 接口&quot;&gt;&lt;/a&gt;EntityManager 接口&lt;/h2&gt;&lt;p&gt;任何持久层框架都会提供一个管理持久层的 API。这个 API 一般都会提供基础的增删改查功能，通过它就可以管理持久化上下文。在 Java 持久层框架中，最常使用的接口就是 EntityManager。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="https://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="https://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate 实战第二版 中文翻译 管理数据篇(一)</title>
    <link href="https://biyw.cf/posts/3c14a1db.html"/>
    <id>https://biyw.cf/posts/3c14a1db.html</id>
    <published>2021-12-12T13:33:45.567Z</published>
    <updated>2022-02-03T08:07:12.563Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;管理数据&quot;&gt;&lt;a href=&quot;#管理数据&quot; class=&quot;headerlink&quot; title=&quot;管理数据&quot;&gt;&lt;/a&gt;管理数据&lt;/h2&gt;&lt;h3 id=&quot;entity-持久化过程中的生命周期&quot;&gt;&lt;a href=&quot;#entity-持久化过程中的生命周期&quot; class=&quot;headerlink&quot; title=&quot;entity 持久化过程中的生命周期&quot;&gt;&lt;/a&gt;entity 持久化过程中的生命周期&lt;/h3&gt;&lt;p&gt;因为 JPA 是一种透明的持久化机制，classes 不用关心他们自己的持久化行为，这样在写业务代码时就不需要关心数据是会被持久化还是仅仅保存在内存中。&lt;/p&gt;
&lt;p&gt;应用层在调用方法时真的没必要关心实体的持久化。例如，你在调用Item#calculate-TotalPrice()业务方法时一点也不用关心持久化的事情。任何与持久化有关的应用，无论是否要把内存的数据保存到数据库中都必须使用持久化服务。换句话说，你必须使用 Java Persistence 的接口存储和查询数据。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="翻译" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="ORM" scheme="https://biyw.cf/tags/ORM/"/>
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="Hibernate" scheme="https://biyw.cf/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch，CyclicBarrier，Semaphore及AQS介绍</title>
    <link href="https://biyw.cf/posts/a33de4ce.html"/>
    <id>https://biyw.cf/posts/a33de4ce.html</id>
    <published>2021-12-05T07:10:31.558Z</published>
    <updated>2022-02-03T08:07:12.615Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;CountDownLatch适用于在多线程的场景需要等待所有子线程全部执行完毕之后再做操作的场景。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="多线程" scheme="https://biyw.cf/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="源码阅读" scheme="https://biyw.cf/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://biyw.cf/posts/4eb3381c.html"/>
    <id>https://biyw.cf/posts/4eb3381c.html</id>
    <published>2021-12-05T06:57:16.379Z</published>
    <updated>2022-02-03T08:07:12.577Z</updated>
    
    
    <summary type="html">&lt;p&gt;在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。 但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。 当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://biyw.cf/tags/Java/"/>
    
    <category term="分布式" scheme="https://biyw.cf/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="多线程" scheme="https://biyw.cf/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【通过抓包学网络】TCP三次握手与四次挥手﻿</title>
    <link href="https://biyw.cf/posts/b65feaa2.html"/>
    <id>https://biyw.cf/posts/b65feaa2.html</id>
    <published>2021-12-05T06:47:29.126Z</published>
    <updated>2022-02-03T08:07:12.593Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文章是通过wireshark来抓包的，如果你对这个工具不熟悉可以看这篇文章&lt;a href=&quot;https://blog.csdn.net/qq_43005544/article/details/116504407&quot;&gt;wireshark 简易教程&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Wireshark" scheme="https://biyw.cf/tags/Wireshark/"/>
    
    <category term="网络" scheme="https://biyw.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark 简明教程</title>
    <link href="https://biyw.cf/posts/65f8076a.html"/>
    <id>https://biyw.cf/posts/65f8076a.html</id>
    <published>2021-12-05T06:42:55.422Z</published>
    <updated>2022-02-03T08:07:12.584Z</updated>
    
    
    <summary type="html">&lt;p&gt;Wireshark 作为一款免费的抓包工具深受工程师们的喜爱，下面就简单介绍一下如何使用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://biyw.cf/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Wireshark" scheme="https://biyw.cf/tags/Wireshark/"/>
    
    <category term="网络" scheme="https://biyw.cf/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
